{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"I am branch test-deleting-ref","title":"Home"},{"location":"api/","text":"API Documentation \u00b6 Controller \u00b6 tm2py.controller \u00b6 RunController - model operation controller. Main interface to start a TM2PY model run. Provide one or more configuration files in .toml format (by convention a scenario.toml and a model.toml) Typical usage example: from tm2py.controller import RunController controller = RunController( [r\u201dexample_union\\scenario.toml\u201d, r\u201dexample_union\\model.toml\u201d]) controller.run() Or from the command-line: python \\tm2py\\tm2py\\controller.py \u2013s scenario.toml \u2013m model.toml RunController \u00b6 Main operational interface for model runs. Provide one or more config files in TOML (*.toml) format, and a run directory. If the run directory is not provided the root directory of the first config_file is used. Properties config: root Configuration object logger: logger object top_sheet: placeholder for top sheet functionality (not implemented yet) trace: placeholder for trace functionality (not implemented yet) run_dir: root run directory for the model run iteration: current running (or last started) iteration component: current running (or last started) Component object EmmeManager object for centralized Emme-related (highway and transit assignments and skims) utilities. list of components which have completed, tuple of (iteration, name, Component object) Source code in tm2py/controller.py class RunController : \"\"\"Main operational interface for model runs. Provide one or more config files in TOML (*.toml) format, and a run directory. If the run directory is not provided the root directory of the first config_file is used. Properties: config: root Configuration object logger: logger object top_sheet: placeholder for top sheet functionality (not implemented yet) trace: placeholder for trace functionality (not implemented yet) run_dir: root run directory for the model run iteration: current running (or last started) iteration component: current running (or last started) Component object emme_manager: EmmeManager object for centralized Emme-related (highway and transit assignments and skims) utilities. complete_components: list of components which have completed, tuple of (iteration, name, Component object) \"\"\" def __init__ ( self , config_file : Union [ List [ str ], str ] = None , run_dir : str = None ): if not isinstance ( config_file , list ): config_file = [ config_file ] if run_dir is None : run_dir = os . path . abspath ( os . path . dirname ( config_file [ 0 ])) self . _run_dir = run_dir self . config = Configuration . load_toml ( config_file ) self . logger = Logger ( self ) self . top_sheet = None self . trace = None self . completed_components = [] # mapping from defined names referenced in config to Component objects self . _component_map = { k : v ( self ) for k , v in component_cls_map . items ()} self . _emme_manager = None self . _iteration = None self . _component = None self . _queued_components = [] self . _queue_components () @property def run_dir ( self ) -> str : \"\"\"The root run directory of the model run\"\"\" return self . _run_dir @property def iteration ( self ) -> int : \"\"\"Current iteration of model\"\"\" return self . _iteration @property def component ( self ) -> Component : \"\"\"Current component of model\"\"\" return self . _component @property def emme_manager ( self ) -> EmmeManager : \"\"\"Cached Emme Manager object\"\"\" if self . _emme_manager is None : self . _init_emme_manager () return self . _emme_manager def _init_emme_manager ( self ): \"\"\"Initialize Emme manager, start Emme desktop App, and initialize Modeller\"\"\" self . _emme_manager = EmmeManager () project = self . _emme_manager . project ( os . path . join ( self . run_dir , self . config . emme . project_path ) ) # Initialize Modeller to use Emme assignment tools and other APIs self . _emme_manager . modeller ( project ) def run ( self ): \"\"\"Main interface to run model\"\"\" self . _iteration = None self . validate_inputs () for iteration , name , component in self . _queued_components : if self . _iteration != iteration : self . logger . log_time ( f \"Start iteration { iteration } \" ) self . _iteration = iteration self . _component = component component . run () self . completed_components . append (( iteration , name , component )) def _queue_components ( self ): \"\"\"Add components per iteration to queue according to input Config\"\"\" self . _queued_components = [] if self . config . run . start_iteration == 0 : self . _queued_components += [ ( 0 , c_name , self . _component_map [ c_name ]) for c_name in self . config . run . initial_components ] iteration_nums = range ( max ( 1 , self . config . run . start_iteration ), self . config . run . end_iteration + 1 ) iteration_components = [ self . _component_map [ c_name ] for c_name in self . config . run . global_iteration_components ] self . _queued_components += list ( itertools . product ( iteration_nums , iteration_components , self . config . run . global_iteration_components , ) ) self . _queued_components += [ ( self . config . run . end_iteration + 1 , self . _component_map [ c_name ]) for c_name in self . config . run . final_components ] if self . config . run . start_component : start_index = [ idx for idx , c in enumerate ( self . _queued_components ) if self . config . run . start_component == c [ 1 ] ][ 0 ] self . _queued_components = self . _queued_components [ start_index :] def validate_inputs ( self ): \"\"\"Validate input state prior to run\"\"\" already_validated_components = set () for _ , name , component in self . _queued_components : if name not in already_validated_components : component . validate_inputs () already_validated_components . add ( name ) component : Component property readonly \u00b6 Current component of model emme_manager : EmmeManager property readonly \u00b6 Cached Emme Manager object iteration : int property readonly \u00b6 Current iteration of model run_dir : str property readonly \u00b6 The root run directory of the model run run ( self ) \u00b6 Main interface to run model Source code in tm2py/controller.py def run ( self ): \"\"\"Main interface to run model\"\"\" self . _iteration = None self . validate_inputs () for iteration , name , component in self . _queued_components : if self . _iteration != iteration : self . logger . log_time ( f \"Start iteration { iteration } \" ) self . _iteration = iteration self . _component = component component . run () self . completed_components . append (( iteration , name , component )) validate_inputs ( self ) \u00b6 Validate input state prior to run Source code in tm2py/controller.py def validate_inputs ( self ): \"\"\"Validate input state prior to run\"\"\" already_validated_components = set () for _ , name , component in self . _queued_components : if name not in already_validated_components : component . validate_inputs () already_validated_components . add ( name ) Components \u00b6 Base Component \u00b6 tm2py.components.component \u00b6 Root component ABC Component ( ABC ) \u00b6 Base component class for tm2py top-level inheritance. Examples: :: class MyComponent(Component): 1 2 3 4 5 6 7 8 9 10 11 12 13 def __init__(self, controller): super().__init__(controller) self._parameter = None def run(self): self._step1() self._step2() def _step1(self): pass def _step2(self): pass Source code in tm2py/components/component.py class Component ( ABC ): \"\"\"Base component class for tm2py top-level inheritance. Example: :: class MyComponent(Component): def __init__(self, controller): super().__init__(controller) self._parameter = None def run(self): self._step1() self._step2() def _step1(self): pass def _step2(self): pass \"\"\" def __init__ ( self , controller : RunController ): self . _controller = controller self . _trace = None @property def controller ( self ): \"\"\"Parent controller\"\"\" return self . _controller def get_abs_path ( self , rel_path : str ): \"\"\"Get the absolute path from the root run directory given a relative path.\"\"\" return os . path . join ( self . controller . run_dir , rel_path ) def get_emme_scenario ( self , emmebank_path : str , time_period : str ) -> EmmeScenario : \"\"\"Get the Emme scenario object from the Emmebank at emmebank_path for the time_period ID. Args: emmebank_path: valid Emmebank path, absolute or relative to root run directory time_period: valid time_period ID Returns Emme Scenario object (see Emme API Reference) \"\"\" if not os . path . isabs ( emmebank_path ): emmebank_path = self . get_abs_path ( emmebank_path ) emmebank = self . controller . emme_manager . emmebank ( emmebank_path ) scenario_id = { tp . name : tp . emme_scenario_id for tp in self . config . time_periods }[ time_period ] return emmebank . scenario ( scenario_id ) @property def config ( self ): \"\"\"Configuration settings loaded from config files\"\"\" return self . controller . config @property def top_sheet ( self ): \"\"\"docstring placeholder for top sheet\"\"\" return self . controller . top_sheet @property def logger ( self ): \"\"\"docstring placeholder for logger\"\"\" return self . controller . logger @property def trace ( self ): \"\"\"docstring placeholder for trace\"\"\" return self . _trace def validate_inputs ( self ): \"\"\"Validate inputs are correct at model initiation, fail fast if not\"\"\" @abstractmethod def run ( self ): \"\"\"Run model component\"\"\" def report_progress ( self ): \"\"\"Write progress to log file\"\"\" def test_component ( self ): \"\"\"Run stand-alone component test\"\"\" def write_top_sheet ( self ): \"\"\"Write key outputs to the model top sheet\"\"\" def verify ( self ): \"\"\"Verify component outputs / results\"\"\" def time_period_names ( self ) -> List [ str ]: \"\"\"Return input time_period name or names and return list of time_period names. Returns: list of string names of time periods \"\"\" return [ time . name for time in self . config . time_periods ] config property readonly \u00b6 Configuration settings loaded from config files controller property readonly \u00b6 Parent controller logger property readonly \u00b6 docstring placeholder for logger top_sheet property readonly \u00b6 docstring placeholder for top sheet trace property readonly \u00b6 docstring placeholder for trace get_abs_path ( self , rel_path ) \u00b6 Get the absolute path from the root run directory given a relative path. Source code in tm2py/components/component.py def get_abs_path ( self , rel_path : str ): \"\"\"Get the absolute path from the root run directory given a relative path.\"\"\" return os . path . join ( self . controller . run_dir , rel_path ) get_emme_scenario ( self , emmebank_path , time_period ) \u00b6 Get the Emme scenario object from the Emmebank at emmebank_path for the time_period ID. Parameters: Name Type Description Default emmebank_path str valid Emmebank path, absolute or relative to root run directory required time_period str valid time_period ID required Returns Emme Scenario object (see Emme API Reference) Source code in tm2py/components/component.py def get_emme_scenario ( self , emmebank_path : str , time_period : str ) -> EmmeScenario : \"\"\"Get the Emme scenario object from the Emmebank at emmebank_path for the time_period ID. Args: emmebank_path: valid Emmebank path, absolute or relative to root run directory time_period: valid time_period ID Returns Emme Scenario object (see Emme API Reference) \"\"\" if not os . path . isabs ( emmebank_path ): emmebank_path = self . get_abs_path ( emmebank_path ) emmebank = self . controller . emme_manager . emmebank ( emmebank_path ) scenario_id = { tp . name : tp . emme_scenario_id for tp in self . config . time_periods }[ time_period ] return emmebank . scenario ( scenario_id ) report_progress ( self ) \u00b6 Write progress to log file Source code in tm2py/components/component.py def report_progress ( self ): \"\"\"Write progress to log file\"\"\" run ( self ) \u00b6 Run model component Source code in tm2py/components/component.py @abstractmethod def run ( self ): \"\"\"Run model component\"\"\" test_component ( self ) \u00b6 Run stand-alone component test Source code in tm2py/components/component.py def test_component ( self ): \"\"\"Run stand-alone component test\"\"\" time_period_names ( self ) \u00b6 Return input time_period name or names and return list of time_period names. Returns: list of string names of time periods Source code in tm2py/components/component.py def time_period_names ( self ) -> List [ str ]: \"\"\"Return input time_period name or names and return list of time_period names. Returns: list of string names of time periods \"\"\" return [ time . name for time in self . config . time_periods ] validate_inputs ( self ) \u00b6 Validate inputs are correct at model initiation, fail fast if not Source code in tm2py/components/component.py def validate_inputs ( self ): \"\"\"Validate inputs are correct at model initiation, fail fast if not\"\"\" verify ( self ) \u00b6 Verify component outputs / results Source code in tm2py/components/component.py def verify ( self ): \"\"\"Verify component outputs / results\"\"\" write_top_sheet ( self ) \u00b6 Write key outputs to the model top sheet Source code in tm2py/components/component.py def write_top_sheet ( self ): \"\"\"Write key outputs to the model top sheet\"\"\" Demand Components \u00b6 tm2py.components.demand special \u00b6 Demand components module demand \u00b6 Demand loading from OMX to Emme database PrepareDemand ( Component , ABC ) \u00b6 Abstract base class to import and average demand. Source code in tm2py/components/demand/demand.py class PrepareDemand ( Component , ABC ): \"\"\"Abstract base class to import and average demand.\"\"\" def __init__ ( self , controller : RunController ): super () . __init__ ( controller ) self . _emmebank = None def _read ( self , path , name , num_zones , factor = None ): with OMXManager ( path , \"r\" ) as omx_file : demand = omx_file . read ( name ) if factor is not None : demand = factor * demand demand = self . _redim_demand ( demand , num_zones ) return demand @staticmethod def _redim_demand ( demand , num_zones ): _shape = demand . shape if _shape != ( num_zones , num_zones ): demand = np . pad ( demand , (( 0 , num_zones - _shape [ 0 ]), ( 0 , num_zones - _shape [ 1 ])) ) return demand # Disable too many arguments recommendation # pylint: disable=R0913 def _save_demand ( self , name , demand , scenario , description = \"\" , apply_msa = False ): matrix = self . _emmebank . matrix ( f 'mf\" { name } \"' ) msa_iteration = self . controller . iteration if not apply_msa or msa_iteration <= 1 : if not matrix : ident = self . _emmebank . available_matrix_identifier ( \"FULL\" ) matrix = self . _emmebank . create_matrix ( ident ) matrix . name = name matrix . description = description else : if not matrix : raise Exception ( f \"error averaging demand: matrix { name } does not exist\" ) prev_demand = matrix . get_numpy_data ( scenario . id ) demand = prev_demand + ( 1.0 / msa_iteration ) * ( demand - prev_demand ) matrix . set_numpy_data ( demand , scenario . id ) def _create_zero_matrix ( self ): zero_matrix = self . _emmebank . matrix ( 'ms\"zero\"' ) if zero_matrix is None : ident = self . _emmebank . available_matrix_identifier ( \"SCALAR\" ) zero_matrix = self . _emmebank . create_matrix ( ident ) zero_matrix . name = \"zero\" zero_matrix . description = \"zero demand matrix\" zero_matrix . data = 0 PrepareHighwayDemand ( PrepareDemand ) \u00b6 Import and average highway demand. Demand is imported from OMX files based on reference file paths and OMX matrix names in highway assignment config (highway.classes). The demand is average using MSA with the current demand matrices (in the Emmebank) if the controller.iteration > 1. Parameters: Name Type Description Default controller RunController parent RunController object required Source code in tm2py/components/demand/demand.py class PrepareHighwayDemand ( PrepareDemand ): \"\"\"Import and average highway demand. Demand is imported from OMX files based on reference file paths and OMX matrix names in highway assignment config (highway.classes). The demand is average using MSA with the current demand matrices (in the Emmebank) if the controller.iteration > 1. Args: controller: parent RunController object \"\"\" def __init__ ( self , controller : RunController ): super () . __init__ ( controller ) self . _emmebank_path = None # @LogStartEnd(\"prepare highway demand\") def run ( self ): \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\" self . _emmebank_path = self . get_abs_path ( self . config . emme . highway_database_path ) self . _emmebank = self . controller . emme_manager . emmebank ( self . _emmebank_path ) self . _create_zero_matrix () for time in self . time_period_names (): for klass in self . config . highway . classes : self . _prepare_demand ( klass . name , klass . description , klass . demand , time ) def _prepare_demand ( self , name : str , description : str , demand_config : List [ Dict [ str , Union [ str , float ]]], time_period : str , ): \"\"\"Load demand from OMX files and save to Emme matrix for highway assignment. Average with previous demand (MSA) if the current iteration > 1 Args: name (str): the name of the highway assignment class description (str): the description for the highway assignment class demand_config (dict): the list of file cross-reference(s) for the demand to be loaded {\"source\": <name of demand model component>, \"name\": <OMX key name>, \"factor\": <factor to apply to demand in this file>} time_period (str): the time time_period ID (name) \"\"\" scenario = self . get_emme_scenario ( self . _emmebank_path , time_period ) num_zones = len ( scenario . zone_numbers ) demand = self . _read_demand ( demand_config [ 0 ], time_period , num_zones ) for file_config in demand_config [ 1 :]: demand = demand + self . _read_demand ( file_config , time_period , num_zones ) demand_name = f \" { time_period } _ { name } \" description = f \" { time_period } { description } demand\" self . _save_demand ( demand_name , demand , scenario , description , apply_msa = True ) def _read_demand ( self , file_config , time_period , num_zones ): # Load demand from cross-referenced source file, # the named demand model component under the key highway_demand_file source = file_config [ \"source\" ] name = file_config [ \"name\" ] . format ( period = time_period . upper ()) factor = file_config . get ( \"factor\" ) path = self . get_abs_path ( self . config [ source ] . highway_demand_file ) return self . _read ( path . format ( period = time_period ), name , num_zones , factor ) run ( self ) \u00b6 Open combined demand OMX files from demand models and prepare for assignment. Source code in tm2py/components/demand/demand.py def run ( self ): \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\" self . _emmebank_path = self . get_abs_path ( self . config . emme . highway_database_path ) self . _emmebank = self . controller . emme_manager . emmebank ( self . _emmebank_path ) self . _create_zero_matrix () for time in self . time_period_names (): for klass in self . config . highway . classes : self . _prepare_demand ( klass . name , klass . description , klass . demand , time ) Network Components \u00b6 tm2py.components.network special \u00b6 highway special \u00b6 highway_assign \u00b6 Highway assignment and skim component. Performs equilibrium traffic assignment and generates resulting skims. The assignmend is configured using the \u201chighway\u201d table in the source config. See the config documentation for details. The traffic assignment runs according to the list of assignment classes under highway.classes. Other relevant parameters from the config are emme.num_processors: number of processors as integer or \u201cMAX\u201d or \u201cMAX-N\u201d time_periods[].emme_scenario_id: Emme scenario number to use for each period time_periods[].highway_capacity_factor The Emme network must have the following attributes available: Link: - \u201clength\u201d in feet - \u201cvdf\u201d, volume delay function (volume delay functions must also be setup) - \u201c@useclass\u201d, vehicle-class restrictions classification, auto-only, HOV only - \u201c@free_flow_time\u201d, the free flow time (in minutes) - \u201c@tollXX_YY\u201d, the toll for period XX and class subgroup (see truck class) named YY, used together with @tollbooth to generate @bridgetoll_YY and @valuetoll_YY - \u201c@maz_flow\u201d, the background traffic MAZ-to-MAZ SP assigned flow from highway_maz, if controller.iteration > 0 - modes: must be set on links and match the specified mode codes in the traffic config Network results: - @flow_XX: link PCE flows per class, where XX is the class name in the config - timau: auto travel time - volau: total assigned flow in PCE Notes: - Output matrices are in miles, minutes, and cents (2010 dollars) and are stored/ as real values; - Intrazonal distance/time is one half the distance/time to the nearest neighbor; - Intrazonal bridge and value tolls are assumed to be zero AssignmentClass \u00b6 Highway assignment class, represents data from config and conversion to Emme specs Source code in tm2py/components/network/highway/highway_assign.py class AssignmentClass : \"\"\"Highway assignment class, represents data from config and conversion to Emme specs\"\"\" def __init__ ( self , class_config , time_period , iteration ): self . class_config = class_config self . time_period = time_period self . iteration = iteration self . name = class_config [ \"name\" ] . lower () self . skims = class_config . get ( \"skims\" , []) @property def emme_highway_class_spec ( self ) -> EmmeHighwayClassSpec : \"\"\"Construct and return Emme traffic assignment class specification Converted from input config (highway.classes), see Emme Help for SOLA traffic assignment for specification details. Adds time_period as part of demand and skim matrix names. Returns: A nested dictionary corresponding to the expected Emme traffic class specification used in the SOLA assignment. \"\"\" if self . iteration == 0 : demand_matrix = 'ms\"zero\"' else : demand_matrix = f 'mf\" { self . time_period } _ { self . name } \"' class_spec = { \"mode\" : self . class_config . mode_code , \"demand\" : demand_matrix , \"generalized_cost\" : { \"link_costs\" : f \"@cost_ { self . name . lower () } \" , # cost in $0.01 # $/hr -> min/$0.01 \"perception_factor\" : 0.6 / self . class_config . value_of_time , }, \"results\" : { \"link_volumes\" : f \"@flow_ { self . name . lower () } \" , \"od_travel_times\" : { \"shortest_paths\" : f \"mf { self . time_period } _ { self . name } _time\" }, }, \"path_analyses\" : self . emme_class_analysis , } return class_spec @property def emme_class_analysis ( self ) -> List [ EmmeHighwayAnalysisSpec ]: \"\"\"Construct and return a list of path analyses specs which generate the required skims. Returns: A list of nested dictionaries corresponding to the Emme path analysis (per-class) specification used in the SOLA assignment. \"\"\" class_analysis = [] if \"time\" in self . skims : class_analysis . append ( self . emme_analysis_spec ( f \"@cost_ { self . name } \" . lower (), f \"mf { self . time_period } _ { self . name } _cost\" , ) ) for skim_type in self . skims : if skim_type == \"time\" : continue if \"_\" in skim_type : skim_type , group = skim_type . split ( \"_\" ) else : group = \"\" matrix_name = f \"mf { self . time_period } _ { self . name } _ { skim_type }{ group } \" class_analysis . append ( self . emme_analysis_spec ( self . skim_analysis_link_attribute ( skim_type , group ), matrix_name , ) ) return class_analysis @property def skim_matrices ( self ) -> List [ str ]: \"\"\"Returns: List of skim matrix names for this class.\"\"\" skim_matrices = [] if \"time\" in self . skims : skim_matrices . extend ( [ f \" { self . time_period } _ { self . name } _time\" , f \" { self . time_period } _ { self . name } _cost\" , ] ) for skim_type in self . skims : if skim_type == \"time\" : continue if \"_\" in skim_type : skim_type , group = skim_type . split ( \"_\" ) else : group = \"\" skim_matrices . append ( f \" { self . time_period } _ { self . name } _ { skim_type }{ group } \" ) return skim_matrices @staticmethod def emme_analysis_spec ( link_attr : str , matrix_name : str ) -> EmmeHighwayAnalysisSpec : \"\"\"Returns Emme highway class path analysis spec. See Emme Help for SOLA assignment for full specification details. Args: link_attr: input link attribute for which to sum values along the paths matrix_name: full matrix name to store the result of the path analysis Returns: The nested dictionary specification which will generate the skim of link attribute values. \"\"\" analysis_spec = { \"link_component\" : link_attr , \"turn_component\" : None , \"operator\" : \"+\" , \"selection_threshold\" : { \"lower\" : None , \"upper\" : None }, \"path_to_od_composition\" : { \"considered_paths\" : \"ALL\" , \"multiply_path_proportions_by\" : { \"analyzed_demand\" : False , \"path_value\" : True , }, }, \"results\" : { \"od_values\" : matrix_name , \"selected_link_volumes\" : None , \"selected_turn_volumes\" : None , }, } return analysis_spec @staticmethod def skim_analysis_link_attribute ( skim : str , group : str ) -> str : \"\"\"Return the link attribute name for the specified skim type and group. Args: skim: name of skim requested, one of dist, hovdist, tolldist, freeflowtime, bridgetoll, or valuetoll group: subgroup name for the bridgetoll or valuetoll, corresponds to one of the names from config.highway.tolls.dst_vehicle_group_names Returns: A string of the link attribute name used in the analysis. \"\"\" lookup = { \"dist\" : \"length\" , # NOTE: length must be in miles \"hovdist\" : \"@hov_length\" , \"tolldist\" : \"@toll_length\" , \"freeflowtime\" : \"@free_flow_time\" , \"bridgetoll\" : f \"@bridgetoll_ { group } \" , \"valuetoll\" : f \"@valuetoll_ { group } \" , } return lookup [ skim ] emme_class_analysis : List [ EmmeHighwayAnalysisSpec ] property readonly \u00b6 Construct and return a list of path analyses specs which generate the required skims. Returns: Type Description List[EmmeHighwayAnalysisSpec] A list of nested dictionaries corresponding to the Emme path analysis (per-class) specification used in the SOLA assignment. emme_highway_class_spec : EmmeHighwayClassSpec property readonly \u00b6 Construct and return Emme traffic assignment class specification Converted from input config (highway.classes), see Emme Help for SOLA traffic assignment for specification details. Adds time_period as part of demand and skim matrix names. Returns: Type Description EmmeHighwayClassSpec A nested dictionary corresponding to the expected Emme traffic class specification used in the SOLA assignment. skim_matrices : List [ str ] property readonly \u00b6 emme_analysis_spec ( link_attr , matrix_name ) staticmethod \u00b6 Returns Emme highway class path analysis spec. See Emme Help for SOLA assignment for full specification details. Parameters: Name Type Description Default link_attr str input link attribute for which to sum values along the paths required matrix_name str full matrix name to store the result of the path analysis required Returns: Type Description EmmeHighwayAnalysisSpec The nested dictionary specification which will generate the skim of link attribute values. Source code in tm2py/components/network/highway/highway_assign.py @staticmethod def emme_analysis_spec ( link_attr : str , matrix_name : str ) -> EmmeHighwayAnalysisSpec : \"\"\"Returns Emme highway class path analysis spec. See Emme Help for SOLA assignment for full specification details. Args: link_attr: input link attribute for which to sum values along the paths matrix_name: full matrix name to store the result of the path analysis Returns: The nested dictionary specification which will generate the skim of link attribute values. \"\"\" analysis_spec = { \"link_component\" : link_attr , \"turn_component\" : None , \"operator\" : \"+\" , \"selection_threshold\" : { \"lower\" : None , \"upper\" : None }, \"path_to_od_composition\" : { \"considered_paths\" : \"ALL\" , \"multiply_path_proportions_by\" : { \"analyzed_demand\" : False , \"path_value\" : True , }, }, \"results\" : { \"od_values\" : matrix_name , \"selected_link_volumes\" : None , \"selected_turn_volumes\" : None , }, } return analysis_spec skim_analysis_link_attribute ( skim , group ) staticmethod \u00b6 Return the link attribute name for the specified skim type and group. Parameters: Name Type Description Default skim str name of skim requested, one of dist, hovdist, tolldist, freeflowtime, bridgetoll, or valuetoll required group str subgroup name for the bridgetoll or valuetoll, corresponds to one of the names from config.highway.tolls.dst_vehicle_group_names required Returns: Type Description str A string of the link attribute name used in the analysis. Source code in tm2py/components/network/highway/highway_assign.py @staticmethod def skim_analysis_link_attribute ( skim : str , group : str ) -> str : \"\"\"Return the link attribute name for the specified skim type and group. Args: skim: name of skim requested, one of dist, hovdist, tolldist, freeflowtime, bridgetoll, or valuetoll group: subgroup name for the bridgetoll or valuetoll, corresponds to one of the names from config.highway.tolls.dst_vehicle_group_names Returns: A string of the link attribute name used in the analysis. \"\"\" lookup = { \"dist\" : \"length\" , # NOTE: length must be in miles \"hovdist\" : \"@hov_length\" , \"tolldist\" : \"@toll_length\" , \"freeflowtime\" : \"@free_flow_time\" , \"bridgetoll\" : f \"@bridgetoll_ { group } \" , \"valuetoll\" : f \"@valuetoll_ { group } \" , } return lookup [ skim ] HighwayAssignment ( Component ) \u00b6 Highway assignment and skims. Parameters: Name Type Description Default controller RunController parent RunController object required Source code in tm2py/components/network/highway/highway_assign.py class HighwayAssignment ( Component ): \"\"\"Highway assignment and skims. Args: controller: parent RunController object \"\"\" def __init__ ( self , controller : RunController ): super () . __init__ ( controller ) self . _num_processors = tools . parse_num_processors ( self . config . emme . num_processors ) self . _matrix_cache = None self . _skim_matrices = [] @LogStartEnd ( \"Highway assignment and skims\" , level = \"STATUS\" ) def run ( self ): \"\"\"Run highway assignment\"\"\" demand = PrepareHighwayDemand ( self . controller ) demand . run () for time in self . time_period_names (): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) with self . _setup ( scenario , time ): iteration = self . controller . iteration assign_classes = [ AssignmentClass ( c , time , iteration ) for c in self . config . highway . classes ] if iteration > 0 : self . _copy_maz_flow ( scenario ) else : self . _reset_background_traffic ( scenario ) self . _create_skim_matrices ( scenario , assign_classes ) assign_spec = self . _get_assignment_spec ( assign_classes ) # self.logger.log_dict(assign_spec, level=\"DEBUG\") with self . logger . log_start_end ( \"Run SOLA assignment with path analyses\" , level = \"INFO\" ): assign = self . controller . emme_manager . tool ( \"inro.emme.traffic_assignment.sola_traffic_assignment\" ) assign ( assign_spec , scenario , chart_log_interval = 1 ) # Subtract non-time costs from gen cost to get the raw travel time for emme_class_spec in assign_spec [ \"classes\" ]: self . _calc_time_skim ( emme_class_spec ) # Set intra-zonal for time and dist to be 1/2 nearest neighbour for class_config in self . config . highway . classes : self . _set_intrazonal_values ( time , class_config [ \"name\" ], class_config [ \"skims\" ], ) self . _export_skims ( scenario , time ) @_context def _setup ( self , scenario : EmmeScenario , time_period : str ): \"\"\"Setup and teardown for Emme Matrix cache and list of skim matrices Args: scenario: Emme scenario object time_period: time period name \"\"\" self . _matrix_cache = MatrixCache ( scenario ) self . _skim_matrices = [] msg = f \"Highway assignment for period { time_period } \" with self . logger . log_start_end ( msg , level = \"STATUS\" ): try : yield finally : self . _matrix_cache . clear () self . _matrix_cache = None self . _skim_matrices = [] def _copy_maz_flow ( self , scenario : EmmeScenario ): \"\"\"Copy maz_flow from MAZ demand assignment to ul1 for background traffic. Args: scenario: Emme scenario object\"\"\" self . logger . log_time ( \"Copy @maz_flow to ul1 for background traffic\" , indent = True , level = \"DETAIL\" ) net_calc = NetworkCalculator ( scenario ) net_calc ( \"ul1\" , \"@maz_flow\" ) def _reset_background_traffic ( self , scenario : EmmeScenario ): \"\"\"Set ul1 for background traffic to 0 (no maz-maz flow) Args: scenario: Emme scenario object\"\"\" self . logger . log_time ( \"Set ul1 to 0 for background traffic\" , indent = True , level = \"DETAIL\" ) net_calc = NetworkCalculator ( scenario ) net_calc ( \"ul1\" , \"0\" ) def _create_skim_matrices ( self , scenario : EmmeScenario , assign_classes : List [ AssignmentClass ] ): \"\"\"Create matrices to store skim results in Emme database. Also add the matrices to list of self._skim_matrices. Args: scenario: Emme scenario object assign_classes: list of AssignmentClass objects \"\"\" create_matrix = self . controller . emme_manager . tool ( \"inro.emme.data.matrix.create_matrix\" ) with self . logger . log_start_end ( \"Creating skim matrices\" , level = \"DETAIL\" ): for klass in assign_classes : for matrix_name in klass . skim_matrices : matrix = scenario . emmebank . matrix ( f 'mf\" { matrix_name } \"' ) if not matrix : matrix = create_matrix ( \"mf\" , matrix_name , scenario = scenario , overwrite = True ) self . logger . log ( f \"Create matrix name: { matrix_name } , id: { matrix . id } \" , level = \"DEBUG\" , ) self . _skim_matrices . append ( matrix ) def _get_assignment_spec ( self , assign_classes : List [ AssignmentClass ] ) -> EmmeTrafficAssignmentSpec : \"\"\"Generate template Emme SOLA assignment specification Args: assign_classes: list of AssignmentClass objects Returns Emme specification for SOLA traffic assignment \"\"\" relative_gap = self . config . highway . relative_gap max_iterations = self . config . highway . max_iterations # NOTE: mazmazvol as background traffic in link.data1 (\"ul1\") base_spec = { \"type\" : \"SOLA_TRAFFIC_ASSIGNMENT\" , \"background_traffic\" : { \"link_component\" : \"ul1\" , \"turn_component\" : None , \"add_transit_vehicles\" : False , }, \"classes\" : [ klass . emme_highway_class_spec for klass in assign_classes ], \"stopping_criteria\" : { \"max_iterations\" : max_iterations , \"best_relative_gap\" : 0.0 , \"relative_gap\" : relative_gap , \"normalized_gap\" : 0.0 , }, \"performance_settings\" : { \"number_of_processors\" : self . _num_processors }, } return base_spec def _calc_time_skim ( self , emme_class_spec : EmmeHighwayClassSpec ): \"\"\"Calculate the real time skim =gen_cost-per_fac*link_costs. Args: emme_class_spec: dictionary of the per-class spec sub-section from the Emme SOLA assignment spec, classes list \"\"\" od_travel_times = emme_class_spec [ \"results\" ][ \"od_travel_times\" ][ \"shortest_paths\" ] if od_travel_times is not None : # Total link costs is always the first analysis cost = emme_class_spec [ \"path_analyses\" ][ 0 ][ \"results\" ][ \"od_values\" ] factor = emme_class_spec [ \"generalized_cost\" ][ \"perception_factor\" ] gencost_data = self . _matrix_cache . get_data ( od_travel_times ) cost_data = self . _matrix_cache . get_data ( cost ) time_data = gencost_data - ( factor * cost_data ) self . _matrix_cache . set_data ( od_travel_times , time_data ) def _set_intrazonal_values ( self , time_period : str , class_name : str , skims : List [ str ] ): \"\"\"Set the intrazonal values to 1/2 nearest neighbour for time and distance skims. Args: time_period: time period name (from config) class_name: highway class name (from config) skims: list of requested skims (from config) \"\"\" for skim_name in skims : matrix_name = f \"mf { time_period } _ { class_name } _ { skim_name } \" if skim_name in [ \"time\" , \"distance\" , \"freeflowtime\" , \"hovdist\" , \"tolldist\" ]: data = self . _matrix_cache . get_data ( matrix_name ) # NOTE: sets values for external zones as well np . fill_diagonal ( data , np . inf ) data [ np . diag_indices_from ( data )] = 0.5 * np . nanmin ( data , 1 ) self . _matrix_cache . set_data ( matrix_name , data ) def _export_skims ( self , scenario : EmmeScenario , time_period : str ): \"\"\"Export skims to OMX files by period. Args: scenario: Emme scenario object time_period: time period name \"\"\" # NOTE: skims in separate file by period omx_file_path = self . get_abs_path ( self . config . highway . output_skim_path . format ( period = time_period ) ) os . makedirs ( os . path . dirname ( omx_file_path ), exist_ok = True ) with OMXManager ( omx_file_path , \"w\" , scenario , matrix_cache = self . _matrix_cache ) as omx_file : omx_file . write_matrices ( self . _skim_matrices ) run ( self ) \u00b6 Run highway assignment Source code in tm2py/components/network/highway/highway_assign.py @LogStartEnd ( \"Highway assignment and skims\" , level = \"STATUS\" ) def run ( self ): \"\"\"Run highway assignment\"\"\" demand = PrepareHighwayDemand ( self . controller ) demand . run () for time in self . time_period_names (): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) with self . _setup ( scenario , time ): iteration = self . controller . iteration assign_classes = [ AssignmentClass ( c , time , iteration ) for c in self . config . highway . classes ] if iteration > 0 : self . _copy_maz_flow ( scenario ) else : self . _reset_background_traffic ( scenario ) self . _create_skim_matrices ( scenario , assign_classes ) assign_spec = self . _get_assignment_spec ( assign_classes ) # self.logger.log_dict(assign_spec, level=\"DEBUG\") with self . logger . log_start_end ( \"Run SOLA assignment with path analyses\" , level = \"INFO\" ): assign = self . controller . emme_manager . tool ( \"inro.emme.traffic_assignment.sola_traffic_assignment\" ) assign ( assign_spec , scenario , chart_log_interval = 1 ) # Subtract non-time costs from gen cost to get the raw travel time for emme_class_spec in assign_spec [ \"classes\" ]: self . _calc_time_skim ( emme_class_spec ) # Set intra-zonal for time and dist to be 1/2 nearest neighbour for class_config in self . config . highway . classes : self . _set_intrazonal_values ( time , class_config [ \"name\" ], class_config [ \"skims\" ], ) self . _export_skims ( scenario , time ) highway_maz \u00b6 Assigns and skims MAZ-to-MAZ demand along shortest generalized cost path. MAZ to MAZ demand is read in from separate OMX matrices as defined under the config table highway.maz_to_maz.demand_county_groups, The demand is expected to be short distance (e.g. <0.5 miles), or within the same TAZ. The demand is grouped into bins of origin -> all destinations, by distance (straight-line) to furthest destination. This limits the size of the shortest path calculated to the minimum required. The bin edges have been predefined after testing as (in miles): [0.0, 0.9, 1.2, 1.8, 2.5, 5.0, 10.0, max_dist] Input: Emme network with: Link attributes: - time attribute, either timau (resulting VDF congested time) or @free_flow_time Node attributes: @maz_id, x, y, and #node_county Demand matrices under highway.maz_to_maz.demand_file, and can have a placeholder auto_{period} MAZ_AUTO {number}_{period}.omx Output: The resulting MAZ-MAZ flows are saved in link @maz_flow which is used as background traffic in the equilibrium Highway assignment. AssignMAZSPDemand ( Component ) \u00b6 MAZ-to-MAZ shortest-path highway assignment. Calculates shortest path between MAZs with demand in the Emme network and assigns flow. Source code in tm2py/components/network/highway/highway_maz.py class AssignMAZSPDemand ( Component ): \"\"\"MAZ-to-MAZ shortest-path highway assignment. Calculates shortest path between MAZs with demand in the Emme network and assigns flow. \"\"\" # skip Too many instance attributes recommendation, it is OK as is # pylint: disable=R0902 def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path highway assignment. Args: controller: parent Controller object \"\"\" super () . __init__ ( controller ) self . _scenario = None # bins: performance parameter: crow-fly distance bins # to limit shortest path calculation by origin to furthest destination # semi-exposed for performance testing self . _bin_edges = _default_bin_edges self . _debug = False # Internal attributes to track data through the sequence of steps self . _eb_dir = None self . _mazs = None self . _demand = None self . _max_dist = 0 self . _network = None self . _root_index = None self . _leaf_index = None @LogStartEnd () def run ( self ): \"\"\"Run MAZ-to-MAZ shortest path assignment.\"\"\" emme_manager = self . controller . emme_manager emmebank = emme_manager . emmebank ( self . get_abs_path ( self . config . emme . highway_database_path ) ) self . _eb_dir = os . path . dirname ( emmebank . path ) county_groups = {} for group in self . config . highway . maz_to_maz . demand_county_groups : county_groups [ group . number ] = group . counties for time in self . time_period_names (): with self . logger . log_start_end ( f \"period { time } \" ): self . _scenario = self . get_emme_scenario ( emmebank . path , time ) with self . _setup ( time ): self . _prepare_network () for i , names in county_groups . items (): maz_ids = self . _get_county_mazs ( names ) if len ( maz_ids ) == 0 : self . logger . log ( f \"warning: no mazs for counties { ', ' . join ( names ) } \" ) continue self . _process_demand ( time , i , maz_ids ) demand_bins = self . _group_demand () for i , demand_group in enumerate ( demand_bins ): self . _find_roots_and_leaves ( demand_group [ \"demand\" ]) self . _set_link_cost_maz () self . _run_shortest_path ( time , i , demand_group [ \"dist\" ]) self . _assign_flow ( time , i , demand_group [ \"demand\" ]) @_context def _setup ( self , time : str ): \"\"\"Context setup / teardown, initializes internal attributes. Args: time: name of the time period \"\"\" self . _mazs = None self . _demand = _defaultdict ( lambda : []) self . _max_dist = 0 self . _network = None self . _root_index = None self . _leaf_index = None attributes = [ ( \"LINK\" , \"@link_cost\" , \"total cost MAZ-MAZ\" ), ( \"LINK\" , \"@link_cost_maz\" , \"cost MAZ-MAZ, unused MAZs blocked\" ), ( \"NODE\" , \"@maz_root\" , \"Flag for MAZs which are roots\" ), ( \"NODE\" , \"@maz_leaf\" , \"Flag for MAZs which are leaves\" ), ] with self . controller . emme_manager . temp_attributes_and_restore ( self . _scenario , attributes ): try : yield finally : if not self . _debug : self . _mazs = None self . _demand = None self . _network = None self . _root_index = None self . _leaf_index = None # delete sp path files for bin_no in range ( len ( self . _bin_edges )): file_path = os . path . join ( self . _eb_dir , f \"sp_ { time } _ { bin_no } .ebp\" ) if os . path . exists ( file_path ): os . remove ( file_path ) def _prepare_network ( self ): \"\"\"Calculate link cost (travel time + bridge tolls + operating cost) and load network. Reads Emme network from disk for later node lookups. Optimized to only load attribute values of interest, additional attributes must be added in order to be read from disk. \"\"\" if self . _scenario . has_traffic_results : time_attr = \"(@free_flow_time.max.timau)\" else : time_attr = \"@free_flow_time\" self . logger . log ( f \"Calculating link costs using time { time_attr } \" , level = \"DEBUG\" ) vot = self . config . highway . maz_to_maz . value_of_time op_cost = self . config . highway . maz_to_maz . operating_cost_per_mile net_calc = NetworkCalculator ( self . _scenario ) net_calc ( \"@link_cost\" , f \" { time_attr } + 0.6 / { vot } * (length * { op_cost } )\" ) self . _network = self . controller . emme_manager . get_network ( self . _scenario , { \"NODE\" : [ \"@maz_id\" , \"x\" , \"y\" , \"#node_county\" ], \"LINK\" : []} ) self . _network . create_attribute ( \"LINK\" , \"temp_flow\" ) def _get_county_mazs ( self , counties : List [ str ]) -> List [ EmmeNode ]: \"\"\"Get all MAZ nodes which are located in one of these counties. Used the node attribute #node_county to identify the node location. Name must be an exact match. Catches a mapping of the county names to nodes so nodes are processed only once. Args: counties: list of county names Returns: List of MAZ nodes (Emme Node) which are in these counties. \"\"\" network = self . _network # NOTE: every maz must have a valid #node_county if self . _mazs is None : self . _mazs = _defaultdict ( lambda : []) for node in network . nodes (): if node [ \"@maz_id\" ]: self . _mazs [ node [ \"#node_county\" ]] . append ( node ) mazs = [] for county in counties : mazs . extend ( self . _mazs [ county ]) return sorted ( mazs , key = lambda n : n [ \"@maz_id\" ]) def _process_demand ( self , time : str , index : int , maz_ids : List [ EmmeNode ]): \"\"\"Loads the demand from file and groups by origin node. Sets the demand to self._demand for later processing, grouping the demand in a dictionary by origin node (Emme Node object) to list of dictionaries {\"orig\": orig_node, \"dest\": dest_node, \"dem\": demand, \"dist\": dist} Args: time: time period name index: group index of the demand file, used to find the file by name maz_ids: indexed list of MAZ ID nodes for the county group (active counties for this demand file) \"\"\" data = self . _read_demand_array ( time , index ) origins , destinations = data . nonzero () for orig , dest in zip ( origins , destinations ): # skip intra-maz demand if orig == dest : continue orig_node = maz_ids [ orig ] dest_node = maz_ids [ dest ] dist = _sqrt ( ( dest_node . x - orig_node . x ) ** 2 + ( dest_node . y - orig_node . y ) ** 2 ) if dist > self . _max_dist : self . _max_dist = dist self . _demand [ orig_node ] . append ( { \"orig\" : orig_node , \"dest\" : dest_node , \"dem\" : data [ orig ][ dest ], \"dist\" : dist , } ) def _read_demand_array ( self , time : str , index : int ) -> NumpyArray : \"\"\"Load the demand from file with the specified time and index name. Args: time: time period name index: group index of the demand file, used to find the file by name \"\"\" file_path_tmplt = self . get_abs_path ( self . config . highway . maz_to_maz . demand_file ) omx_file_path = self . get_abs_path ( file_path_tmplt . format ( period = time , number = index ) ) with OMXManager ( omx_file_path , \"r\" ) as omx_file : demand_array = omx_file . read ( \"M0\" ) return demand_array def _group_demand ( self , ) -> List [ Dict [ str , Union [ float , List [ Dict [ str , Union [ float , EmmeNode ]]]]]]: \"\"\"Process the demand loaded from files and create groups based on the origin to the furthest destination with demand. Returns: List of dictionaries, containing the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" # group demand from same origin into distance bins by furthest # distance destination to limit shortest path search radius bin_edges = self . _bin_edges [:] if bin_edges [ - 1 ] < self . _max_dist / 5280.0 : bin_edges . append ( self . _max_dist / 5280.0 ) demand_groups = [ { \"dist\" : edge , \"demand\" : []} for i , edge in enumerate ( bin_edges [ 1 :]) ] for data in self . _demand . values (): max_dist = max ( entry [ \"dist\" ] for entry in data ) / 5280.0 for group in demand_groups : if max_dist < group [ \"dist\" ]: group [ \"demand\" ] . extend ( data ) break for group in demand_groups : self . logger . log_time ( f \"bin dist { group [ 'dist' ] } , size { len ( group [ 'demand' ]) } \" , level = \"DEBUG\" ) # Filter out groups without any demand demand_groups = [ group for group in demand_groups if group [ \"demand\" ]] return demand_groups def _find_roots_and_leaves ( self , demand : List [ Dict [ str , Union [ float , EmmeNode ]]]): \"\"\"Label available MAZ root nodes and leaf nodes for the path calculation. The MAZ nodes which are found as origins in the demand are \"activated\" by setting @maz_root to non-zero, and similarly the leaves have @maz_leaf set to non-zero. Args: demand: list of dictionaries, containing the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" network = self . _network attrs_to_init = [( \"NODE\" , [ \"@maz_root\" , \"@maz_leaf\" ]), ( \"LINK\" , [ \"maz_cost\" ])] for domain , attrs in attrs_to_init : for name in attrs : if name in network . attributes ( domain ): network . delete_attribute ( domain , name ) network . create_attribute ( domain , name ) root_maz_ids = {} leaf_maz_ids = {} for data in demand : o_node , d_node = data [ \"orig\" ], data [ \"dest\" ] root_maz_ids [ o_node . number ] = o_node [ \"@maz_root\" ] = o_node [ \"@maz_id\" ] leaf_maz_ids [ d_node . number ] = d_node [ \"@maz_leaf\" ] = d_node [ \"@maz_id\" ] self . _root_index = { p : i for i , p in enumerate ( sorted ( root_maz_ids . keys ()))} self . _leaf_index = { q : i for i , q in enumerate ( sorted ( leaf_maz_ids . keys ()))} self . controller . emme_manager . copy_attr_values ( \"NODE\" , self . _network , self . _scenario , [ \"@maz_root\" , \"@maz_leaf\" ] ) def _set_link_cost_maz ( self ): \"\"\"Set link cost used in the shortest path forbidden using unavailable connectors. Copy the pre-calculated cost @link_cost to @link_cost_maz, setting value to 1e20 on connectors to unused zone leaves / from unused roots. \"\"\" # forbid egress from MAZ nodes which are not demand roots / # access to MAZ nodes which are not demand leafs net_calc = NetworkCalculator ( self . _scenario ) net_calc . add_calc ( \"@link_cost_maz\" , \"@link_cost\" ) net_calc . add_calc ( \"@link_cost_maz\" , \"1e20\" , \"@maz_root=0 and !@maz_id=0\" ) net_calc . add_calc ( \"@link_cost_maz\" , \"1e20\" , \"@maz_leafj=0 and !@maz_idj=0\" ) net_calc . run () def _run_shortest_path ( self , time : str , bin_no : int , max_radius : float ): \"\"\"Run the shortest path tool to generate paths between the marked nodes. Args: time: time period name bin_no: bin number (id) for this demand segment max_radius: max unit coordinate distance to limit search tree \"\"\" shortest_paths_tool = self . controller . emme_manager . tool ( \"inro.emme.network_calculation.shortest_path\" ) max_radius = max_radius * 5280 + 100 # add some buffer for rounding error ext = \"ebp\" if _USE_BINARY else \"txt\" file_name = f \"sp_ { time } _ { bin_no } . { ext } \" num_processors = parse_num_processors ( self . config . emme . num_processors ) spec = { \"type\" : \"SHORTEST_PATH\" , \"modes\" : [ self . config . highway . maz_to_maz . mode_code ], \"root_nodes\" : \"@maz_root\" , \"leaf_nodes\" : \"@maz_leaf\" , \"link_cost\" : \"@link_cost_maz\" , \"path_constraints\" : { \"max_radius\" : max_radius , \"uturn_allowed\" : False , \"through_leaves\" : False , \"through_centroids\" : False , \"exclude_forbidden_turns\" : False , }, \"results\" : { \"skim_output\" : { \"file\" : \"\" , \"format\" : \"TEXT\" , \"return_numpy\" : False , \"analyses\" : [], }, \"path_output\" : { \"format\" : \"BINARY\" if _USE_BINARY else \"TEXT\" , \"file\" : os . path . join ( self . _eb_dir , file_name ), }, }, \"performance_settings\" : { \"number_of_processors\" : num_processors , \"direction\" : \"FORWARD\" , \"method\" : \"STANDARD\" , }, } shortest_paths_tool ( spec , self . _scenario ) def _assign_flow ( self , time : str , bin_no : int , demand : List [ Dict [ str , Union [ float , EmmeNode ]]] ): \"\"\"Assign the demand along the paths generated from the shortest path tool. Args: time: time period name bin_no: bin number (id) for this demand segment demand: list of dictionaries, containing the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" if _USE_BINARY : self . _assign_flow_binary ( time , bin_no , demand ) else : self . _assign_flow_text ( time , bin_no , demand ) def _assign_flow_text ( self , time : str , bin_no : int , demand : List [ Dict [ str , Union [ float , EmmeNode ]]] ): \"\"\"Assign the demand along the paths generated from the shortest path tool. The paths are read from a text format file, see Emme help for details. Demand is summed in self._network (in memory) using temp_flow attribute and written to scenario (Emmebank / disk) @maz_flow. Args: time: time period name bin_no: bin number (id) for this demand segment demand: list of dictionaries, containin the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" paths = self . _load_text_format_paths ( time , bin_no ) not_assigned , assigned = 0 , 0 for data in demand : orig , dest , dem = data [ \"orig\" ] . number , data [ \"dest\" ] . number , data [ \"dem\" ] path = paths . get ( orig , {}) . get ( dest ) if path is None : not_assigned += dem continue i_node = orig for j_node in path : link = self . _network . link ( i_node , j_node ) link [ \"temp_flow\" ] += dem i_node = j_node assigned += dem self . logger . log_time ( f \"ASSIGN bin { bin_no } : total: { len ( demand ) } \" , level = \"DEBUG\" ) self . logger . log_time ( f \"assigned: { assigned } , not assigned: { not_assigned } \" , level = \"DEBUG\" ) def _load_text_format_paths ( self , time : str , bin_no : int ) -> Dict [ int , Dict [ int , List [ int ]]]: \"\"\"Load all paths from text file and return as nested dictionary. Args: time: time period name bin_no: bin number (id) for this demand segment Returns: All paths as a nested dictionary, path = paths[origin][destination], using the node IDs as integers. \"\"\" paths = _defaultdict ( lambda : {}) with open ( os . path . join ( self . _eb_dir , f \"sp_ { time } _ { bin_no } .txt\" ), \"r\" , encoding = \"utf8\" , ) as paths_file : for line in paths_file : nodes = [ int ( x ) for x in line . split ()] paths [ nodes [ 0 ]][ nodes [ - 1 ]] = nodes [ 1 :] return paths def _assign_flow_binary ( self , time : str , bin_no : int , demand : List [ Dict [ str , Union [ float , EmmeNode ]]] ): \"\"\"Assign the demand along the paths generated from the shortest path tool. The paths are read from a binary format file, see Emme help for details. Demand is summed in self._network (in memory) using temp_flow attribute and written to scenario (Emmebank / disk) @maz_flow. Args: time: time period name bin_no: bin number (id) for this demand segment demand: list of dictionaries, containin the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" file_name = f \"sp_ { time } _ { bin_no } .ebp\" with open ( os . path . join ( self . _eb_dir , file_name ), \"rb\" ) as paths_file : # read set of path pointers by Orig-Dest sequence from file offset , leaves_nb , path_indicies = self . _get_path_indices ( paths_file ) assigned = 0 not_assigned = 0 bytes_read = offset * 8 # for all orig-dest pairs with demand, load path from file for data in demand : # get file position based on orig-dest index start , end = self . _get_path_location ( data [ \"orig\" ] . number , data [ \"dest\" ] . number , leaves_nb , path_indicies ) # no path found, disconnected zone if start == end : not_assigned += data [ \"dem\" ] continue paths_file . seek ( start * 4 + offset * 8 ) self . _assign_path_flow ( paths_file , start , end , data [ \"dem\" ]) assigned += data [ \"dem\" ] bytes_read += ( end - start ) * 4 self . controller . emme_manager . copy_attr_values ( \"LINK\" , self . _network , self . _scenario , [ \"temp_flow\" ], [ \"@maz_flow\" ] ) self . logger . log_time ( f \"ASSIGN bin { bin_no } , total { len ( demand ) } , assign \" f \" { assigned } , not assign { not_assigned } , bytes { bytes_read } \" , level = \"DEBUG\" , ) @staticmethod def _get_path_indices ( paths_file : BinaryIO ) -> [ int , int , _array . array ]: \"\"\"Get the path header indices. See the Emme Shortest path tool doc for additional details on reading this file. Args: paths_file: binary file access to the generated paths file Returns: 2 ints + array of ints: offset, leafs_nb, path_indicies offset: starting index to read the paths leafs_nb: number of leafs in the shortest path file path_indicies: array of the start index for each root, leaf path in paths_file. \"\"\" # read first 4 integers from file (Q=64-bit unsigned integers) header = _array . array ( \"Q\" ) header . fromfile ( paths_file , 4 ) roots_nb , leaves_nb = header [ 2 : 4 ] # Load sequence of path indices (positions by orig-dest index), # pointing to list of path node IDs in file path_indicies = _array . array ( \"Q\" ) path_indicies . fromfile ( paths_file , roots_nb * leaves_nb + 1 ) offset = roots_nb * leaves_nb + 1 + 4 return offset , leaves_nb , path_indicies def _get_path_location ( self , orig : EmmeNode , dest : EmmeNode , leaves_nb : int , path_indicies : _array . array , ) -> [ int , int ]: \"\"\"Get the location in the paths_file to read. Args: orig: Emme Node object, origin MAZ to query the path dest: Emme Node object, destination MAZ to query the path leaves_nb: number of leaves path_indicies: array of the start index for each root, leaf path in paths_file. Returns: Two integers, start, end start: starting index to read Node ID bytes from paths_file end: ending index to read bytes from paths_file \"\"\" p_index = self . _root_index [ orig ] q_index = self . _leaf_index [ dest ] index = p_index * leaves_nb + q_index start = path_indicies [ index ] end = path_indicies [ index + 1 ] return start , end def _assign_path_flow ( self , paths_file : BinaryIO , start : int , end : int , demand : float ): \"\"\"Add demand to link temp_flow for the path. Args: paths_file: binary file access to read path from start: starting index to read Node ID bytes from paths_file end: ending index to read bytes from paths_file demand: flow demand to add on link \"\"\" # load sequence of Node IDs which define the path (L=32-bit unsigned integers) path = _array . array ( \"L\" ) path . fromfile ( paths_file , end - start ) # proccess path to sequence of links and add flow path_iter = iter ( path ) i_node = next ( path_iter ) for j_node in path_iter : link = self . _network . link ( i_node , j_node ) link [ \"temp_flow\" ] += demand i_node = j_node __init__ ( self , controller ) special \u00b6 MAZ-to-MAZ shortest-path highway assignment. Parameters: Name Type Description Default controller RunController parent Controller object required Source code in tm2py/components/network/highway/highway_maz.py def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path highway assignment. Args: controller: parent Controller object \"\"\" super () . __init__ ( controller ) self . _scenario = None # bins: performance parameter: crow-fly distance bins # to limit shortest path calculation by origin to furthest destination # semi-exposed for performance testing self . _bin_edges = _default_bin_edges self . _debug = False # Internal attributes to track data through the sequence of steps self . _eb_dir = None self . _mazs = None self . _demand = None self . _max_dist = 0 self . _network = None self . _root_index = None self . _leaf_index = None run ( self ) \u00b6 Run MAZ-to-MAZ shortest path assignment. Source code in tm2py/components/network/highway/highway_maz.py @LogStartEnd () def run ( self ): \"\"\"Run MAZ-to-MAZ shortest path assignment.\"\"\" emme_manager = self . controller . emme_manager emmebank = emme_manager . emmebank ( self . get_abs_path ( self . config . emme . highway_database_path ) ) self . _eb_dir = os . path . dirname ( emmebank . path ) county_groups = {} for group in self . config . highway . maz_to_maz . demand_county_groups : county_groups [ group . number ] = group . counties for time in self . time_period_names (): with self . logger . log_start_end ( f \"period { time } \" ): self . _scenario = self . get_emme_scenario ( emmebank . path , time ) with self . _setup ( time ): self . _prepare_network () for i , names in county_groups . items (): maz_ids = self . _get_county_mazs ( names ) if len ( maz_ids ) == 0 : self . logger . log ( f \"warning: no mazs for counties { ', ' . join ( names ) } \" ) continue self . _process_demand ( time , i , maz_ids ) demand_bins = self . _group_demand () for i , demand_group in enumerate ( demand_bins ): self . _find_roots_and_leaves ( demand_group [ \"demand\" ]) self . _set_link_cost_maz () self . _run_shortest_path ( time , i , demand_group [ \"dist\" ]) self . _assign_flow ( time , i , demand_group [ \"demand\" ]) SkimMAZCosts ( Component ) \u00b6 MAZ-to-MAZ shortest-path skim of time, distance and toll Source code in tm2py/components/network/highway/highway_maz.py class SkimMAZCosts ( Component ): \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll\"\"\" def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll Args: controller: parent RunController object \"\"\" super () . __init__ ( controller ) self . _scenario = None self . _network = None @LogStartEnd () def run ( self ): \"\"\"Run shortest path skims for all available MAZ-to-MAZ O-D pairs. Runs a shortest path builder for each county, using a maz_skim_cost to limit the search. The valid gen cost (time + cost), distance and toll (drive alone) are written to CSV at the output_skim_file path: FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL The following config inputs are used directly in this component. Note also that the network mode_code is prepared in the highway_network component using the excluded_links. config.highway.maz_to_maz: skim_period: name of the period used for the skim, must match one the defined config.time_periods demand_county_groups: used for the list of counties, creates a list out of all listed counties under [].counties output_skim_file: relative path to save the skims value_of_time: value of time used to convert tolls and auto operating cost operating_cost_per_mile: auto operating cost max_skim_cost: max cost value used to limit the shortest path search mode_code: config.emme.num_processors \"\"\" ref_period = None ref_period_name = self . config . highway . maz_to_maz . skim_period for period in self . config . time_periods : if period . name == ref_period_name : ref_period = period break if ref_period is None : raise Exception ( \"highway.maz_to_maz.skim_period: is not the name of an existing time_period\" ) self . _scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , ref_period . name ) # prepare output file and write header output = self . get_abs_path ( self . config . highway . maz_to_maz . output_skim_file ) os . makedirs ( os . path . dirname ( output ), exist_ok = True ) with open ( output , \"w\" , encoding = \"utf8\" ) as output_file : output_file . write ( \"FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL \\n \" ) counties = [] for group in self . config . highway . maz_to_maz . demand_county_groups : counties . extend ( group . counties ) with self . _setup (): self . _prepare_network () for county in counties : num_roots = self . _mark_roots ( county ) if num_roots == 0 : continue sp_values = self . _run_shortest_path () self . _export_results ( sp_values ) @_context def _setup ( self ): \"\"\"Creates the temp attributes used in the component.\"\"\" attributes = [ ( \"LINK\" , \"@link_cost\" , \"total cost MAZ-MAZ\" ), ( \"NODE\" , \"@maz_root\" , \"selected roots (origins)\" ), ] with self . controller . emme_manager . temp_attributes_and_restore ( self . _scenario , attributes ): try : yield finally : self . _network = None # clear network obj ref to free memory @LogStartEnd () def _prepare_network ( self ): \"\"\"Calculates the link cost in @link_cost and loads the network to self._network\"\"\" net_calc = NetworkCalculator ( self . _scenario ) if self . _scenario . has_traffic_results : time_attr = \"(@free_flow_time.max.timau)\" else : time_attr = \"@free_flow_time\" vot = self . config . highway . maz_to_maz . value_of_time op_cost = self . config . highway . maz_to_maz . operating_cost_per_mile net_calc ( \"@link_cost\" , f \" { time_attr } + 0.6 / { vot } * (length * { op_cost } )\" ) self . _network = self . controller . emme_manager . get_network ( self . _scenario , { \"NODE\" : [ \"@maz_id\" , \"#node_county\" ]} ) def _mark_roots ( self , county : str ) -> int : \"\"\"Mark the available roots in the county.\"\"\" count_roots = 0 for node in self . _network . nodes (): if node [ \"@maz_id\" ] > 0 and node [ \"#node_county\" ] == county : node [ \"@maz_root\" ] = node [ \"@maz_id\" ] count_roots += 1 else : node [ \"@maz_root\" ] = 0 values = self . _network . get_attribute_values ( \"NODE\" , [ \"@maz_root\" ]) self . _scenario . set_attribute_values ( \"NODE\" , [ \"@maz_root\" ], values ) return count_roots def _run_shortest_path ( self ) -> Dict [ str , NumpyArray ]: \"\"\"Run shortest paths tool and return dictionary of skim results name, numpy arrays. O-D pairs are limited by a max cost value from config.highway.maz_to_maz.max_skim_cost, from roots marked by @maz_root to all available leaves at @maz_id. Returns: A dictionary with keys \"COST\", \"DISTANCE\", and \"BRIDGETOLL\", and numpy arrays of SP values for available O-D pairs \"\"\" shortest_paths_tool = self . controller . emme_manager . tool ( \"inro.emme.network_calculation.shortest_path\" ) num_processors = parse_num_processors ( self . config . emme . num_processors ) max_cost = float ( self . config . highway . maz_to_maz . max_skim_cost ) spec = { \"type\" : \"SHORTEST_PATH\" , \"modes\" : [ self . config . highway . maz_to_maz . mode_code ], \"root_nodes\" : \"@maz_root\" , \"leaf_nodes\" : \"@maz_id\" , \"link_cost\" : \"@link_cost\" , \"path_constraints\" : { \"max_cost\" : max_cost , \"uturn_allowed\" : False , \"through_leaves\" : False , \"through_centroids\" : False , \"exclude_forbidden_turns\" : False , }, \"results\" : { \"skim_output\" : { \"return_numpy\" : True , \"analyses\" : [ { \"component\" : \"SHORTEST_PATH_COST\" , \"operator\" : \"+\" , \"name\" : \"COST\" , \"description\" : \"\" , }, { \"component\" : \"length\" , \"operator\" : \"+\" , \"name\" : \"DISTANCE\" , \"description\" : \"\" , }, { \"component\" : \"@bridgetoll_da\" , \"operator\" : \"+\" , \"name\" : \"BRIDGETOLL\" , \"description\" : \"\" , }, ], \"format\" : \"OMX\" , } }, \"performance_settings\" : { \"number_of_processors\" : num_processors , \"direction\" : \"FORWARD\" , \"method\" : \"STANDARD\" , }, } sp_values = shortest_paths_tool ( spec , self . _scenario ) return sp_values def _export_results ( self , sp_values : Dict [ str , NumpyArray ]): \"\"\"Write matrix skims to CSV. The matrices are filtered to omit rows for which the COST is < 0 or > 1e19 (Emme uses 1e20 to indicate inaccessible zone pairs). sp_values: dictionary of matrix costs, with the three keys \"COST\", \"DISTANCE\", and \"BRIDGETOLL\" and Numpy arrays of values \"\"\" # get list of MAZ IDS roots = [ node [ \"@maz_root\" ] for node in self . _network . nodes () if node [ \"@maz_root\" ] ] leaves = [ node [ \"@maz_id\" ] for node in self . _network . nodes () if node [ \"@maz_id\" ]] # build dataframe with output data and to/from MAZ ids root_ids = np . repeat ( roots , len ( leaves )) leaf_ids = leaves * len ( roots ) result_df = pd . DataFrame ( { \"FROM_ZONE\" : root_ids , \"TO_ZONE\" : leaf_ids , \"COST\" : sp_values [ \"COST\" ] . flatten (), \"DISTANCE\" : sp_values [ \"DISTANCE\" ] . flatten (), \"BRIDGETOLL\" : sp_values [ \"BRIDGETOLL\" ] . flatten (), } ) # drop 0's / 1e20 result_df = result_df . query ( \"COST > 0 & COST < 1e19\" ) # write remaining values to text file # FROM_ZONE,TO_ZONE,COST,DISTANCE,BRIDGETOLL output = self . get_abs_path ( self . config . highway . maz_to_maz . output_skim_file ) with open ( output , \"a\" , newline = \"\" , encoding = \"utf8\" ) as output_file : result_df . to_csv ( output_file , header = False , index = False ) __init__ ( self , controller ) special \u00b6 MAZ-to-MAZ shortest-path skim of time, distance and toll Parameters: Name Type Description Default controller RunController parent RunController object required Source code in tm2py/components/network/highway/highway_maz.py def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll Args: controller: parent RunController object \"\"\" super () . __init__ ( controller ) self . _scenario = None self . _network = None run ( self ) \u00b6 Run shortest path skims for all available MAZ-to-MAZ O-D pairs. Runs a shortest path builder for each county, using a maz_skim_cost to limit the search. The valid gen cost (time + cost), distance and toll (drive alone) are written to CSV at the output_skim_file path: FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL The following config inputs are used directly in this component. Note also that the network mode_code is prepared in the highway_network component using the excluded_links. config.highway.maz_to_maz: !!! skim_period \u201cname of the period used for the skim, must match one the\u201d defined config.time_periods !!! demand_county_groups \u201cused for the list of counties, creates a list out\u201d of all listed counties under [].counties output_skim_file: relative path to save the skims value_of_time: value of time used to convert tolls and auto operating cost operating_cost_per_mile: auto operating cost max_skim_cost: max cost value used to limit the shortest path search mode_code: config.emme.num_processors Source code in tm2py/components/network/highway/highway_maz.py @LogStartEnd () def run ( self ): \"\"\"Run shortest path skims for all available MAZ-to-MAZ O-D pairs. Runs a shortest path builder for each county, using a maz_skim_cost to limit the search. The valid gen cost (time + cost), distance and toll (drive alone) are written to CSV at the output_skim_file path: FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL The following config inputs are used directly in this component. Note also that the network mode_code is prepared in the highway_network component using the excluded_links. config.highway.maz_to_maz: skim_period: name of the period used for the skim, must match one the defined config.time_periods demand_county_groups: used for the list of counties, creates a list out of all listed counties under [].counties output_skim_file: relative path to save the skims value_of_time: value of time used to convert tolls and auto operating cost operating_cost_per_mile: auto operating cost max_skim_cost: max cost value used to limit the shortest path search mode_code: config.emme.num_processors \"\"\" ref_period = None ref_period_name = self . config . highway . maz_to_maz . skim_period for period in self . config . time_periods : if period . name == ref_period_name : ref_period = period break if ref_period is None : raise Exception ( \"highway.maz_to_maz.skim_period: is not the name of an existing time_period\" ) self . _scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , ref_period . name ) # prepare output file and write header output = self . get_abs_path ( self . config . highway . maz_to_maz . output_skim_file ) os . makedirs ( os . path . dirname ( output ), exist_ok = True ) with open ( output , \"w\" , encoding = \"utf8\" ) as output_file : output_file . write ( \"FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL \\n \" ) counties = [] for group in self . config . highway . maz_to_maz . demand_county_groups : counties . extend ( group . counties ) with self . _setup (): self . _prepare_network () for county in counties : num_roots = self . _mark_roots ( county ) if num_roots == 0 : continue sp_values = self . _run_shortest_path () self . _export_results ( sp_values ) highway_network \u00b6 Module for highway network preparation steps. Creates required attributes and populates input values needed for highway assignments. The toll values, VDFs, per-class cost (tolls+operating costs), modes and skim link attributes are calculated. The following link attributes are used as input: - \u201c@capclass\u201d: link capclass index - \u201clength\u201d: standard link length, in miles - \u201c@tollbooth\u201d: label to separate bridgetolls from valuetolls - \u201c@tollseg\u201d: toll segment, used to index toll value lookups from the toll file (under config.highway.tolls.file_path) - \u201c@ft\u201d: functional class, used to assign VDFs The following keys and tables are used from the config: highway.tolls.file_path: relative path to input toll file highway.tolls.src_vehicle_group_names: names used in tolls file for toll class values highway.tolls.dst_vehicle_group_names: corresponding names used in network attributes toll classes highway.tolls.tollbooth_start_index: index to split point bridge tolls (< this value) from distance value tolls (>= this value) highway.classes: the list of assignment classes, see the notes under highway_assign for detailed explanation highway.capclass_lookup: the lookup table mapping the link @capclass setting to capacity (@capacity), free_flow_speed (@free_flow_speec) and critical_speed (used to calculate @ja for akcelik type functions) highway.generic_highway_mode_code: unique (with other mode_codes) single character used to label entire auto network in Emme highway.maz_to_maz.mode_code: unique (with other mode_codes) single character used to label MAZ local auto network including connectors The following link attributes are created (overwritten) and are subsequently used in the highway assignments. - \u201c@flow_XX\u201d: link PCE flows per class, where XX is the class name in the config - \u201c@maz_flow\u201d: Assigned MAZ-to-MAZ flow The following attributes are calculated: - vdf: volume delay function to use - \u201c@capacity\u201d: total link capacity - \u201c@ja\u201d: akcelik delay parameter - \u201c@hov_length\u201d: length with HOV lanes - \u201c@toll_length\u201d: length with tolls - \u201c@bridgetoll_YY\u201d: the bridge toll for class subgroup YY - \u201c@valuetoll_YY\u201d: the \u201cvalue\u201d, non-bridge toll for class subgroup YY - \u201c@cost_YY\u201d: total cost for class YY PrepareNetwork ( Component ) \u00b6 Highway network preparation Source code in tm2py/components/network/highway/highway_network.py class PrepareNetwork ( Component ): \"\"\"Highway network preparation\"\"\" @LogStartEnd ( \"prepare network attributes and modes\" ) def run ( self ): \"\"\"Run network preparation step\"\"\" for time in self . time_period_names (): with self . controller . emme_manager . logbook_trace ( f \"prepare for highway assignment { time } \" ): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) self . _create_class_attributes ( scenario , time ) network = scenario . get_network () self . _set_tolls ( network , time ) self . _set_vdf_attributes ( network , time ) self . _set_link_modes ( network ) self . _calc_link_skim_lengths ( network ) self . _calc_link_class_costs ( network ) scenario . publish_network ( network ) def _create_class_attributes ( self , scenario : EmmeScenario , time_period : str ): \"\"\"Create required network attributes including per-class cost and flow attributes.\"\"\" create_attribute = self . controller . emme_manager . tool ( \"inro.emme.data.extra_attribute.create_extra_attribute\" ) attributes = { \"LINK\" : [ ( \"@capacity\" , \"total link capacity\" ), ( \"@ja\" , \"akcelik delay parameter\" ), ( \"@maz_flow\" , \"Assigned MAZ-to-MAZ flow\" ), ( \"@hov_length\" , \"length with HOV lanes\" ), ( \"@toll_length\" , \"length with tolls\" ), ] } # toll field attributes by bridge and value and toll definition dst_veh_groups = self . config . highway . tolls . dst_vehicle_group_names for dst_veh in dst_veh_groups : for toll_type in \"bridge\" , \"value\" : attributes [ \"LINK\" ] . append ( ( f \"@ { toll_type } toll_ { dst_veh } \" , f \" { toll_type } toll value for { dst_veh } \" , ) ) # results for link cost and assigned flow for assign_class in self . config . highway . classes : attributes [ \"LINK\" ] . append ( ( f \"@cost_ { assign_class . name . lower () } \" , f ' { time_period } { assign_class [ \"description\" ] } total costs' [: 40 ], ) ) attributes [ \"LINK\" ] . append ( ( f \"@flow_ { assign_class . name . lower () } \" , f ' { time_period } { assign_class [ \"description\" ] } link volume' [: 40 ], ) ) for domain , attrs in attributes . items (): for name , desc in attrs : create_attribute ( domain , name , desc , overwrite = True , scenario = scenario ) def _set_tolls ( self , network : EmmeNetwork , time_period : str ): \"\"\"Set the tolls in the network from the toll reference file.\"\"\" toll_index = self . _get_toll_indices () src_veh_groups = self . config . highway . tolls . src_vehicle_group_names dst_veh_groups = self . config . highway . tolls . dst_vehicle_group_names tollbooth_start_index = self . config . highway . tolls . tollbooth_start_index for link in network . links (): if link [ \"@tollbooth\" ]: index = ( link [ \"@tollbooth\" ] * 1000 + link [ \"@tollseg\" ] * 10 + link [ \"@useclass\" ] ) data_row = toll_index . get ( index ) if data_row is None : self . logger . log ( f \"set tolls failed index lookup { index } , link { link . id } \" , level = \"TRACE\" , ) continue # tolls will remain at zero # if index is below tollbooth start index then this is a bridge # (point toll), available for all traffic assignment classes if link [ \"@tollbooth\" ] < tollbooth_start_index : for src_veh , dst_veh in zip ( src_veh_groups , dst_veh_groups ): link [ f \"@bridgetoll_ { dst_veh } \" ] = ( data_row [ f \"toll { time_period . lower () } _ { src_veh } \" ] * 100 ) else : # else, this is a tollway with a per-mile charge for src_veh , dst_veh in zip ( src_veh_groups , dst_veh_groups ): link [ f \"@valuetoll_ { dst_veh } \" ] = ( data_row [ f \"toll { time_period . lower () } _ { src_veh } \" ] * link . length * 100 ) def _get_toll_indices ( self ) -> Dict [ int , Dict [ str , str ]]: \"\"\"Get the mapping of toll lookup table from the toll reference file.\"\"\" toll_file_path = self . get_abs_path ( self . config . highway . tolls . file_path ) tolls = {} with open ( toll_file_path , \"r\" , encoding = \"UTF8\" ) as toll_file : header = next ( toll_file ) . split ( \",\" ) for line in toll_file : data = dict ( zip ( header , line . split ( \",\" ))) tolls [ int ( data [ \"fac_index\" ])] = data return tolls def _set_vdf_attributes ( self , network : EmmeNetwork , time_period : str ): \"\"\"Set capacity, VDF and critical speed on links\"\"\" capacity_map = {} critical_speed_map = {} for row in self . config . highway . capclass_lookup : if row . get ( \"capacity\" ) is not None : capacity_map [ row [ \"capclass\" ]] = row . get ( \"capacity\" ) if row . get ( \"critical_speed\" ) is not None : critical_speed_map [ row [ \"capclass\" ]] = row . get ( \"critical_speed\" ) tp_mapping = { tp . name : tp . highway_capacity_factor for tp in self . config . time_periods } period_capacity_factor = tp_mapping [ time_period ] akcelik_vdfs = [ 3 , 4 , 5 , 7 , 8 , 10 , 11 , 12 , 13 , 14 ] for link in network . links (): cap_lanehour = capacity_map [ link [ \"@capclass\" ]] link [ \"@capacity\" ] = cap_lanehour * period_capacity_factor * link [ \"@lanes\" ] link . volume_delay_func = int ( link [ \"@ft\" ]) # re-mapping links with type 99 to type 7 \"local road of minor importance\" if link . volume_delay_func == 99 : link . volume_delay_func = 7 # num_lanes not used directly, but set for reference link . num_lanes = max ( min ( 9.9 , link [ \"@lanes\" ]), 1.0 ) if link . volume_delay_func in akcelik_vdfs and link [ \"@free_flow_speed\" ] > 0 : dist = link . length critical_speed = critical_speed_map [ link [ \"@capclass\" ]] t_c = dist / critical_speed t_o = dist / link [ \"@free_flow_speed\" ] link [ \"@ja\" ] = 16 * ( t_c - t_o ) ** 2 def _set_link_modes ( self , network : EmmeNetwork ): \"\"\"Set the link modes based on the per-class 'excluded_links' set.\"\"\" # first reset link modes (script run more than once) # \"generic_highway_mode_code\" must already be created (in import to Emme script) auto_mode = { network . mode ( self . config . highway . generic_highway_mode_code )} used_modes = { network . mode ( assign_class . mode_code ) for assign_class in self . config . highway . classes } used_modes . add ( network . mode ( self . config . highway . maz_to_maz . mode_code )) for link in network . links (): link . modes -= used_modes if link [ \"@drive_link\" ]: link . modes |= auto_mode for mode in used_modes : if mode is not None : network . delete_mode ( mode ) # Create special access/egress mode for MAZ connectors maz_access_mode = network . create_mode ( \"AUX_AUTO\" , self . config . highway . maz_to_maz . mode_code ) maz_access_mode . description = \"MAZ access\" # create modes from class spec # (duplicate mode codes allowed provided the excluded_links is the same) mode_excluded_links = {} for assign_class in self . config . highway . classes : if assign_class . mode_code in mode_excluded_links : if ( assign_class . excluded_links != mode_excluded_links [ assign_class . mode_code ] ): ex_links1 = mode_excluded_links [ assign_class . mode_code ] ex_links2 = assign_class . excluded_links raise Exception ( f \"config error: highway.classes, duplicated mode codes \" f \"(' { assign_class . mode_code } ') with different excluded \" f \"links: { ex_links1 } and { ex_links2 } \" ) continue mode = network . create_mode ( \"AUX_AUTO\" , assign_class . mode_code ) mode . description = assign_class . name mode_excluded_links [ mode . id ] = assign_class . excluded_links dst_veh_groups = self . config . highway . tolls . dst_vehicle_group_names for link in network . links (): modes = set ( m . id for m in link . modes ) if link . i_node [ \"@maz_id\" ] + link . j_node [ \"@maz_id\" ] > 0 : modes . add ( maz_access_mode . id ) link . modes = modes continue if not link [ \"@drive_link\" ]: continue exclude_links_map = { \"is_sr\" : link [ \"@useclass\" ] in [ 2 , 3 ], \"is_sr2\" : link [ \"@useclass\" ] == 2 , \"is_sr3\" : link [ \"@useclass\" ] == 3 , \"is_auto_only\" : link [ \"@useclass\" ] in [ 2 , 3 , 4 ], } for dst_veh in dst_veh_groups : exclude_links_map [ f \"is_toll_ { dst_veh } \" ] = ( link [ f \"@valuetoll_ { dst_veh } \" ] > 0 ) self . _apply_exclusions ( self . config . highway . maz_to_maz . excluded_links , maz_access_mode . id , modes , exclude_links_map , ) for assign_class in self . config . highway . classes : self . _apply_exclusions ( assign_class . excluded_links , assign_class . mode_code , modes , exclude_links_map , ) link . modes = modes @staticmethod def _apply_exclusions ( excluded_links_criteria : List [ str ], mode_code : str , modes_set : Set [ str ], link_values : Dict [ str , bool ], ): \"\"\"Apply the exclusion criteria to set the link modes.\"\"\" for criteria in excluded_links_criteria : if link_values [ criteria ]: return modes_set . add ( mode_code ) def _calc_link_skim_lengths ( self , network : EmmeNetwork ): \"\"\"Calculate the length attributes used in the highway skims.\"\"\" tollbooth_start_index = self . config . highway . tolls . tollbooth_start_index for link in network . links (): # distance in hov lanes / facilities if 2 <= link [ \"@useclass\" ] <= 3 : link [ \"@hov_length\" ] = link . length else : link [ \"@hov_length\" ] = 0 # distance on non-bridge toll facilities if link [ \"@tollbooth\" ] > tollbooth_start_index : link [ \"@toll_length\" ] = link . length else : link [ \"@toll_length\" ] = 0 def _calc_link_class_costs ( self , network : EmmeNetwork ): \"\"\"Calculate the per-class link cost from the tolls and operating costs.\"\"\" for assign_class in self . config . highway . classes : cost_attr = f \"@cost_ { assign_class . name . lower () } \" op_cost = assign_class [ \"operating_cost_per_mile\" ] toll_factor = assign_class . get ( \"toll_factor\" ) if toll_factor is None : toll_factor = 1.0 for link in network . links (): toll_value = sum ( link [ toll_attr ] for toll_attr in assign_class [ \"toll\" ]) link [ cost_attr ] = link . length * op_cost + toll_value * toll_factor run ( self ) \u00b6 Run network preparation step Source code in tm2py/components/network/highway/highway_network.py @LogStartEnd ( \"prepare network attributes and modes\" ) def run ( self ): \"\"\"Run network preparation step\"\"\" for time in self . time_period_names (): with self . controller . emme_manager . logbook_trace ( f \"prepare for highway assignment { time } \" ): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) self . _create_class_attributes ( scenario , time ) network = scenario . get_network () self . _set_tolls ( network , time ) self . _set_vdf_attributes ( network , time ) self . _set_link_modes ( network ) self . _calc_link_skim_lengths ( network ) self . _calc_link_class_costs ( network ) scenario . publish_network ( network ) transit special \u00b6 Transit assignment and skim module transit_assign \u00b6 Transit assignment module TransitAssignment ( Component ) \u00b6 Run transit assignment. Source code in tm2py/components/network/transit/transit_assign.py class TransitAssignment ( Component ): \"\"\"Run transit assignment.\"\"\" transit_skim \u00b6 Transit skims module TransitSkim ( Component ) \u00b6 Run transit skims Source code in tm2py/components/network/transit/transit_skim.py class TransitSkim ( Component ): \"\"\"Run transit skims\"\"\" Emme Wrappers \u00b6 tm2py.emme special \u00b6 manager \u00b6 Module for Emme Manager for centralized management of Emme projects Centralized location for Emme API imports, which are automatically replaced by unittest.Mock / MagicMock to support testing where Emme is not installed. Contains EmmeManager class for access to common Emme-related procedures (common-code / utility-type methods) and caching access to Emme project, and Modeller. EmmeManager \u00b6 Centralized cache for Emme project and related calls for traffic and transit assignments. Wraps Emme Desktop API (see Emme API Reference for additional details on the Emme objects). Source code in tm2py/emme/manager.py class EmmeManager : \"\"\"Centralized cache for Emme project and related calls for traffic and transit assignments. Wraps Emme Desktop API (see Emme API Reference for additional details on the Emme objects). \"\"\" def __init__ ( self ): # mapping of Emme project path to Emme Desktop API object for reference # (projects are opened only once) self . _project_cache = _EMME_PROJECT_REF def close_all ( self ): \"\"\" Close all open cached Emme project(s). Should be called at the end of the model process / Emme assignments. \"\"\" while self . _project_cache : _ , app = self . _project_cache . popitem () app . close () def create_project ( self , project_dir : str , name : str ) -> EmmeDesktopApp : \"\"\"Create, open and return Emme project Args: project_dir: path to Emme root directory for new Emme project name: name for the Emme project Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" emp_path = _app . create_project ( project_dir , name ) return self . project ( emp_path ) def project ( self , project_path : str ) -> EmmeDesktopApp : \"\"\"Return already open Emme project, or open new Desktop session if not found. Args: project_path: valid path to Emme project *.emp file Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" project_path = os . path . normcase ( os . path . realpath ( project_path )) emme_project = self . _project_cache . get ( project_path ) if emme_project : try : # Check if the Emme window was closed emme_project . current_window () except _socket_error : emme_project = None # if window is not opened in this process, start a new one if emme_project is None : if not os . path . isfile ( project_path ): raise Exception ( f \"Emme project path does not exist { project_path } \" ) emme_project = _app . start_dedicated ( visible = True , user_initials = \"inro\" , project = project_path ) self . _project_cache [ project_path ] = emme_project return emme_project @staticmethod def emmebank ( path : str ) -> Emmebank : \"\"\"Open and return the Emmebank at path. Args: path: valid system path pointing to an Emmebank file Returns: Emmebank object, see Emme API Reference, Database section for details. \"\"\" if not path . endswith ( \"emmebank\" ): path = os . path . join ( path , \"emmebank\" ) return Emmebank ( path ) def change_emmebank_dimensions ( self , emmebank : Emmebank , dimensions : Dict [ str , int ] ): \"\"\"Change the Emmebank dimensions as specified. See the Emme API help for details. Args: emmebank: the Emmebank object to change the dimensions dimensions: dictionary of the specified dimensions to set. \"\"\" dims = emmebank . dimensions new_dims = dims . copy () new_dims . update ( dimensions ) if dims != new_dims : change_dimensions = self . tool ( \"inro.emme.data.database.change_database_dimensions\" ) change_dimensions ( new_dims , emmebank , keep_backup = False ) def modeller ( self , emme_project : EmmeDesktopApp = None ) -> EmmeModeller : \"\"\"Initialize and return Modeller object. If Modeller has not already been initialized it will do so on specified Emme project, or the first Emme project opened if not provided. If already initialized Modeller will reference whichever project was used first. Args: emme_project: open 'Emme Desktop' application (inro.emme.desktop.app) Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" # pylint: disable=E0611, E0401, E1101 try : return EmmeModeller () except AssertionError as error : if emme_project is None : if self . _project_cache : emme_project = next ( iter ( self . _project_cache . values ())) else : raise Exception ( \"modeller not yet initialized and no cached Emme project,\" \" emme_project arg must be provided\" ) from error return EmmeModeller ( emme_project ) def tool ( self , namespace : str ): \"\"\"Return the Modeller tool at namespace. Returns: Corresponding Tool object, see Emme Help for full details. \"\"\" return self . modeller () . tool ( namespace ) @staticmethod @_context def temp_attributes_and_restore ( scenario : EmmeScenario , attributes : List [ List [ str ]] ): \"\"\"Create temp extra attribute and network field, and backup values and state and restore. Allows the use of temporary attributes which may conflict with existing attributes. The temp created attributes are deleted at the end, and if there were pre-existing attributes with the same names the values are restored. Note that name conflicts may still arise in the shorthand inheritance systems for the network hierarchy tree (@node attribute reserves -> @nodei, @nodej, etc, see Emme help Network calculations for full list) which will raise an error in the Emme API. Args: scenario: Emme scenario object attributes: list of attribute details, where details is a list of 3 items for extra attributes and 4 for network fields: domain, name, description[, atype] \"\"\" attrs_to_delete = [] fields_to_delete = [] attrs_to_restore = dict ( ( d , []) for d in [ \"NODE\" , \"LINK\" , \"TURN\" , \"TRANSIT_LINE\" , \"TRANSIT_SEGMENT\" ] ) for details in attributes : domain , name , desc = details [: 3 ] attr = scenario . extra_attribute ( name ) field = scenario . network_field ( domain , name ) if attr or field : attrs_to_restore [ domain ] . append ( name ) elif name . startswith ( \"@\" ): attr = scenario . create_extra_attribute ( domain , name ) attr . description = desc attrs_to_delete . append ( name ) else : atype = details [ 3 ] field = scenario . create_nertwork_field ( domain , name , atype ) field . description = desc fields_to_delete . append (( domain , name )) backup = [] for domain , names in attrs_to_restore . items (): if names : backup . append ( ( domain , names , scenario . get_attribute_values ( domain , names )) ) try : yield finally : for name in attrs_to_delete : scenario . delete_extra_attribute ( name ) for domain , name in fields_to_delete : scenario . delete_network_field ( domain , name ) for domain , names , values in backup : scenario . set_attribute_values ( domain , names , values ) @staticmethod def copy_attr_values ( domain : str , src : Union [ EmmeScenario , EmmeNetwork ], dst : Union [ EmmeScenario , EmmeNetwork ], src_names : List [ str ], dst_names : List [ str ] = None , ): \"\"\"Copy attribute values between Emme scenario (on disk) and network (in memory). Args: domain: attribute domain, one of \"NODE\", \"LINK\", \"TURN\", \"TRANSIT_LINE\", \"TRANSIT_SEGMENT\" src: source Emme scenario or network to load values from dst: destination Emme scenario or network to save values to src_names: names of the attributes for loading values dst_names: optional, names of the attributes to save values as, defaults to using the src_names if not specified Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" if dst_names is None : dst_names = src_names values = src . get_attribute_values ( domain , src_names ) dst . set_attribute_values ( domain , dst_names , values ) def get_network ( self , scenario : EmmeScenario , attributes : Dict [ str , List [ str ]] = None ) -> EmmeNetwork : \"\"\"Read partial Emme network from the scenario for the domains and attributes specified. Optimized load of network object from scenario (disk / emmebank) for only the domains specified, and only reads the attributes specified. The attributes is a dictionary with keys for the required domains, and values as lists of the attributes required by domain. Wrapper for scenario.get_partial_network followed by scenario.get_attribute_values and network.set_attribute_values. Args: scenario: Emme scenario object, see Emme API reference attributes: dictionary of domain names to lists of attribute names Returns: Emme Network object, see Emme API Reference, Network section for details. \"\"\" if attributes is None : return scenario . get_network () network = scenario . get_partial_network ( attributes . keys (), include_attributes = False ) for domain , attrs in attributes . items (): if attrs : self . copy_attr_values ( domain , scenario , network , attrs ) return network @staticmethod def logbook_write ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Emme Logbook at the current nesting level. Wrapper for inro.modeller.logbook_write. Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} logbook_write ( name , value = value , attributes = attributes ) @staticmethod @_context def logbook_trace ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Modeller logbook and create a nest in the Logbook. Wrapper for inro.modeller.logbook_trace. Used in the with statement, e.g. ``` with _emme_tools.logbook_trace('My nest'): _emme_tools.logbook_write('This entry is nested') ``` Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry. \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} with logbook_trace ( name , value = value , attributes = attributes ): yield change_emmebank_dimensions ( self , emmebank , dimensions ) \u00b6 Change the Emmebank dimensions as specified. See the Emme API help for details. Parameters: Name Type Description Default emmebank <MagicMock name='mock.Emmebank' id='140339788584896'> the Emmebank object to change the dimensions required dimensions Dict[str, int] dictionary of the specified dimensions to set. required Source code in tm2py/emme/manager.py def change_emmebank_dimensions ( self , emmebank : Emmebank , dimensions : Dict [ str , int ] ): \"\"\"Change the Emmebank dimensions as specified. See the Emme API help for details. Args: emmebank: the Emmebank object to change the dimensions dimensions: dictionary of the specified dimensions to set. \"\"\" dims = emmebank . dimensions new_dims = dims . copy () new_dims . update ( dimensions ) if dims != new_dims : change_dimensions = self . tool ( \"inro.emme.data.database.change_database_dimensions\" ) change_dimensions ( new_dims , emmebank , keep_backup = False ) close_all ( self ) \u00b6 Close all open cached Emme project(s). Should be called at the end of the model process / Emme assignments. Source code in tm2py/emme/manager.py def close_all ( self ): \"\"\" Close all open cached Emme project(s). Should be called at the end of the model process / Emme assignments. \"\"\" while self . _project_cache : _ , app = self . _project_cache . popitem () app . close () copy_attr_values ( domain , src , dst , src_names , dst_names = None ) staticmethod \u00b6 Copy attribute values between Emme scenario (on disk) and network (in memory). Parameters: Name Type Description Default domain str attribute domain, one of \u201cNODE\u201d, \u201cLINK\u201d, \u201cTURN\u201d, \u201cTRANSIT_LINE\u201d, \u201cTRANSIT_SEGMENT\u201d required src Union[<MagicMock name='mock.Scenario' id='140339788649712'>, <MagicMock name='mock.Network' id='140339788637712'>] source Emme scenario or network to load values from required dst Union[<MagicMock name='mock.Scenario' id='140339788649712'>, <MagicMock name='mock.Network' id='140339788637712'>] destination Emme scenario or network to save values to required src_names List[str] names of the attributes for loading values required dst_names List[str] optional, names of the attributes to save values as, defaults to using the src_names if not specified None Returns: Type Description Emme Modeller object, see Emme API Reference, Modeller section for details. Source code in tm2py/emme/manager.py @staticmethod def copy_attr_values ( domain : str , src : Union [ EmmeScenario , EmmeNetwork ], dst : Union [ EmmeScenario , EmmeNetwork ], src_names : List [ str ], dst_names : List [ str ] = None , ): \"\"\"Copy attribute values between Emme scenario (on disk) and network (in memory). Args: domain: attribute domain, one of \"NODE\", \"LINK\", \"TURN\", \"TRANSIT_LINE\", \"TRANSIT_SEGMENT\" src: source Emme scenario or network to load values from dst: destination Emme scenario or network to save values to src_names: names of the attributes for loading values dst_names: optional, names of the attributes to save values as, defaults to using the src_names if not specified Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" if dst_names is None : dst_names = src_names values = src . get_attribute_values ( domain , src_names ) dst . set_attribute_values ( domain , dst_names , values ) create_project ( self , project_dir , name ) \u00b6 Create, open and return Emme project Parameters: Name Type Description Default project_dir str path to Emme root directory for new Emme project required name str name for the Emme project required Returns: Type Description <MagicMock name='mock.emme.desktop.app.App' id='140339788257936'> Emme Desktop App object, see Emme API Reference, Desktop section for details. Source code in tm2py/emme/manager.py def create_project ( self , project_dir : str , name : str ) -> EmmeDesktopApp : \"\"\"Create, open and return Emme project Args: project_dir: path to Emme root directory for new Emme project name: name for the Emme project Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" emp_path = _app . create_project ( project_dir , name ) return self . project ( emp_path ) emmebank ( path ) staticmethod \u00b6 Open and return the Emmebank at path. Parameters: Name Type Description Default path str valid system path pointing to an Emmebank file required Returns: Type Description <MagicMock name='mock.Emmebank' id='140339788584896'> Emmebank object, see Emme API Reference, Database section for details. Source code in tm2py/emme/manager.py @staticmethod def emmebank ( path : str ) -> Emmebank : \"\"\"Open and return the Emmebank at path. Args: path: valid system path pointing to an Emmebank file Returns: Emmebank object, see Emme API Reference, Database section for details. \"\"\" if not path . endswith ( \"emmebank\" ): path = os . path . join ( path , \"emmebank\" ) return Emmebank ( path ) get_network ( self , scenario , attributes = None ) \u00b6 Read partial Emme network from the scenario for the domains and attributes specified. Optimized load of network object from scenario (disk / emmebank) for only the domains specified, and only reads the attributes specified. The attributes is a dictionary with keys for the required domains, and values as lists of the attributes required by domain. Wrapper for scenario.get_partial_network followed by scenario.get_attribute_values and network.set_attribute_values. Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object, see Emme API reference required attributes Dict[str, List[str]] dictionary of domain names to lists of attribute names None Returns: Type Description <MagicMock name='mock.Network' id='140339788637712'> Emme Network object, see Emme API Reference, Network section for details. Source code in tm2py/emme/manager.py def get_network ( self , scenario : EmmeScenario , attributes : Dict [ str , List [ str ]] = None ) -> EmmeNetwork : \"\"\"Read partial Emme network from the scenario for the domains and attributes specified. Optimized load of network object from scenario (disk / emmebank) for only the domains specified, and only reads the attributes specified. The attributes is a dictionary with keys for the required domains, and values as lists of the attributes required by domain. Wrapper for scenario.get_partial_network followed by scenario.get_attribute_values and network.set_attribute_values. Args: scenario: Emme scenario object, see Emme API reference attributes: dictionary of domain names to lists of attribute names Returns: Emme Network object, see Emme API Reference, Network section for details. \"\"\" if attributes is None : return scenario . get_network () network = scenario . get_partial_network ( attributes . keys (), include_attributes = False ) for domain , attrs in attributes . items (): if attrs : self . copy_attr_values ( domain , scenario , network , attrs ) return network logbook_trace ( name , value = None , attributes = None ) staticmethod \u00b6 Write an entry to the Modeller logbook and create a nest in the Logbook. Wrapper for inro.modeller.logbook_trace. Used in the with statement, e.g. with _emme_tools.logbook_trace('My nest'): _emme_tools.logbook_write('This entry is nested') Parameters: Name Type Description Default name str The title of the logbook entry required attributes Dict[str, Any] Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. None value str Optional. An HTML string value to be displayed in main detail pane of the logbook entry. None Source code in tm2py/emme/manager.py @staticmethod @_context def logbook_trace ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Modeller logbook and create a nest in the Logbook. Wrapper for inro.modeller.logbook_trace. Used in the with statement, e.g. ``` with _emme_tools.logbook_trace('My nest'): _emme_tools.logbook_write('This entry is nested') ``` Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry. \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} with logbook_trace ( name , value = value , attributes = attributes ): yield logbook_write ( name , value = None , attributes = None ) staticmethod \u00b6 Write an entry to the Emme Logbook at the current nesting level. Wrapper for inro.modeller.logbook_write. Parameters: Name Type Description Default name str The title of the logbook entry required attributes Dict[str, Any] Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. None value str Optional. An HTML string value to be displayed in main detail pane of the logbook entry None Source code in tm2py/emme/manager.py @staticmethod def logbook_write ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Emme Logbook at the current nesting level. Wrapper for inro.modeller.logbook_write. Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} logbook_write ( name , value = value , attributes = attributes ) modeller ( self , emme_project = None ) \u00b6 Initialize and return Modeller object. If Modeller has not already been initialized it will do so on specified Emme project, or the first Emme project opened if not provided. If already initialized Modeller will reference whichever project was used first. Parameters: Name Type Description Default emme_project <MagicMock name='mock.emme.desktop.app.App' id='140339788257936'> open \u2018Emme Desktop\u2019 application (inro.emme.desktop.app) None Returns: Type Description <MagicMock name='mock.Modeller' id='140339788213744'> Emme Modeller object, see Emme API Reference, Modeller section for details. Source code in tm2py/emme/manager.py def modeller ( self , emme_project : EmmeDesktopApp = None ) -> EmmeModeller : \"\"\"Initialize and return Modeller object. If Modeller has not already been initialized it will do so on specified Emme project, or the first Emme project opened if not provided. If already initialized Modeller will reference whichever project was used first. Args: emme_project: open 'Emme Desktop' application (inro.emme.desktop.app) Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" # pylint: disable=E0611, E0401, E1101 try : return EmmeModeller () except AssertionError as error : if emme_project is None : if self . _project_cache : emme_project = next ( iter ( self . _project_cache . values ())) else : raise Exception ( \"modeller not yet initialized and no cached Emme project,\" \" emme_project arg must be provided\" ) from error return EmmeModeller ( emme_project ) project ( self , project_path ) \u00b6 Return already open Emme project, or open new Desktop session if not found. Parameters: Name Type Description Default project_path str valid path to Emme project *.emp file required Returns: Type Description <MagicMock name='mock.emme.desktop.app.App' id='140339788257936'> Emme Desktop App object, see Emme API Reference, Desktop section for details. Source code in tm2py/emme/manager.py def project ( self , project_path : str ) -> EmmeDesktopApp : \"\"\"Return already open Emme project, or open new Desktop session if not found. Args: project_path: valid path to Emme project *.emp file Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" project_path = os . path . normcase ( os . path . realpath ( project_path )) emme_project = self . _project_cache . get ( project_path ) if emme_project : try : # Check if the Emme window was closed emme_project . current_window () except _socket_error : emme_project = None # if window is not opened in this process, start a new one if emme_project is None : if not os . path . isfile ( project_path ): raise Exception ( f \"Emme project path does not exist { project_path } \" ) emme_project = _app . start_dedicated ( visible = True , user_initials = \"inro\" , project = project_path ) self . _project_cache [ project_path ] = emme_project return emme_project temp_attributes_and_restore ( scenario , attributes ) staticmethod \u00b6 Create temp extra attribute and network field, and backup values and state and restore. Allows the use of temporary attributes which may conflict with existing attributes. The temp created attributes are deleted at the end, and if there were pre-existing attributes with the same names the values are restored. Note that name conflicts may still arise in the shorthand inheritance systems for the network hierarchy tree (@node attribute reserves -> @nodei, @nodej, etc, see Emme help Network calculations for full list) which will raise an error in the Emme API. Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object required attributes List[List[str]] list of attribute details, where details is a list of 3 items for extra attributes and 4 for network fields: domain, name, description[, atype] required Source code in tm2py/emme/manager.py @staticmethod @_context def temp_attributes_and_restore ( scenario : EmmeScenario , attributes : List [ List [ str ]] ): \"\"\"Create temp extra attribute and network field, and backup values and state and restore. Allows the use of temporary attributes which may conflict with existing attributes. The temp created attributes are deleted at the end, and if there were pre-existing attributes with the same names the values are restored. Note that name conflicts may still arise in the shorthand inheritance systems for the network hierarchy tree (@node attribute reserves -> @nodei, @nodej, etc, see Emme help Network calculations for full list) which will raise an error in the Emme API. Args: scenario: Emme scenario object attributes: list of attribute details, where details is a list of 3 items for extra attributes and 4 for network fields: domain, name, description[, atype] \"\"\" attrs_to_delete = [] fields_to_delete = [] attrs_to_restore = dict ( ( d , []) for d in [ \"NODE\" , \"LINK\" , \"TURN\" , \"TRANSIT_LINE\" , \"TRANSIT_SEGMENT\" ] ) for details in attributes : domain , name , desc = details [: 3 ] attr = scenario . extra_attribute ( name ) field = scenario . network_field ( domain , name ) if attr or field : attrs_to_restore [ domain ] . append ( name ) elif name . startswith ( \"@\" ): attr = scenario . create_extra_attribute ( domain , name ) attr . description = desc attrs_to_delete . append ( name ) else : atype = details [ 3 ] field = scenario . create_nertwork_field ( domain , name , atype ) field . description = desc fields_to_delete . append (( domain , name )) backup = [] for domain , names in attrs_to_restore . items (): if names : backup . append ( ( domain , names , scenario . get_attribute_values ( domain , names )) ) try : yield finally : for name in attrs_to_delete : scenario . delete_extra_attribute ( name ) for domain , name in fields_to_delete : scenario . delete_network_field ( domain , name ) for domain , names , values in backup : scenario . set_attribute_values ( domain , names , values ) tool ( self , namespace ) \u00b6 Return the Modeller tool at namespace. Returns: Type Description Corresponding Tool object, see Emme Help for full details. Source code in tm2py/emme/manager.py def tool ( self , namespace : str ): \"\"\"Return the Modeller tool at namespace. Returns: Corresponding Tool object, see Emme Help for full details. \"\"\" return self . modeller () . tool ( namespace ) matrix \u00b6 Module for Emme-related matrix management. Contains the MatrixCache class for write through matrix data management of Emme matrices (in Emmebank) to avoid repeated read-from-disk of skim matrices during post-assignment processing and export to OMX. Contains the OMXManager which is a thin wrapper on the openmatrix (OMX) library for transfer between Emme (emmebank) <-> OMX files. Integrates with the MatrixCache to support easy write from Emmebank without re-reading data from disk. MatrixCache \u00b6 Write through cache of Emme matrix data via Numpy arrays Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> reference scenario for the active Emmebank and matrix zone system required Source code in tm2py/emme/matrix.py class MatrixCache : \"\"\"Write through cache of Emme matrix data via Numpy arrays Args: scenario: reference scenario for the active Emmebank and matrix zone system \"\"\" def __init__ ( self , scenario : EmmeScenario ): self . _scenario = scenario self . _emmebank = scenario . emmebank # mapping from matrix object to last read/write timestamp for cache invalidation self . _timestamps = {} # cache of Emme matrix data, key: matrix object, value: numpy array of data self . _data = {} def get_data ( self , matrix : Union [ str , EmmeMatrix ]) -> NumpyArray : \"\"\"Get Emme matrix data as numpy array. Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank Returns: The Numpy array of values for this matrix / matrix ID. \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) timestamp = matrix . timestamp prev_timestamp = self . _timestamps . get ( matrix ) if prev_timestamp is None or ( timestamp != prev_timestamp ): self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = matrix . get_numpy_data ( self . _scenario . id ) return self . _data [ matrix ] def set_data ( self , matrix : Union [ str , EmmeMatrix ], data : NumpyArray ): \"\"\"Set numpy array to Emme matrix (write through cache). Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank data: Numpy array, must match the scenario zone system \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) matrix . set_numpy_data ( data , self . _scenario . id ) self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = data def clear ( self ): \"\"\"Clear the cache.\"\"\" self . _timestamps = {} self . _data = {} clear ( self ) \u00b6 Clear the cache. Source code in tm2py/emme/matrix.py def clear ( self ): \"\"\"Clear the cache.\"\"\" self . _timestamps = {} self . _data = {} get_data ( self , matrix ) \u00b6 Get Emme matrix data as numpy array. Parameters: Name Type Description Default matrix Union[str, <MagicMock name='mock.Matrix' id='140339788665808'>] Emme matrix object or unique name / ID for Emme matrix in Emmebank required Returns: Type Description <built-in function array> The Numpy array of values for this matrix / matrix ID. Source code in tm2py/emme/matrix.py def get_data ( self , matrix : Union [ str , EmmeMatrix ]) -> NumpyArray : \"\"\"Get Emme matrix data as numpy array. Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank Returns: The Numpy array of values for this matrix / matrix ID. \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) timestamp = matrix . timestamp prev_timestamp = self . _timestamps . get ( matrix ) if prev_timestamp is None or ( timestamp != prev_timestamp ): self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = matrix . get_numpy_data ( self . _scenario . id ) return self . _data [ matrix ] set_data ( self , matrix , data ) \u00b6 Set numpy array to Emme matrix (write through cache). Parameters: Name Type Description Default matrix Union[str, <MagicMock name='mock.Matrix' id='140339788665808'>] Emme matrix object or unique name / ID for Emme matrix in Emmebank required data <built-in function array> Numpy array, must match the scenario zone system required Source code in tm2py/emme/matrix.py def set_data ( self , matrix : Union [ str , EmmeMatrix ], data : NumpyArray ): \"\"\"Set numpy array to Emme matrix (write through cache). Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank data: Numpy array, must match the scenario zone system \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) matrix . set_numpy_data ( data , self . _scenario . id ) self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = data OMXManager \u00b6 Wrapper for the OMX interface to write from Emme matrices and numpy arrays. Write from Emmebank or Matrix Cache to OMX file, or read from OMX to Numpy. Also supports with statement. Parameters: Name Type Description Default file_path str path of OMX file required mode str \u201cr\u201d, \u201cw\u201d or \u201ca\u201d 'r' scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object for zone system and reference Emmebank None omx_key str \u201cID_NAME\u201d, \u201cNAME\u201d, \u201cID\u201d, format for generating OMX key from Emme matrix data 'NAME' matrix_cache MatrixCache optional, Matrix Cache to support write data from cache (instead of always reading from Emmmebank) None mask_max_value float optional, max value above which to write zero instead (\u201cbig to zero\u201d behavior) None Source code in tm2py/emme/matrix.py class OMXManager : \"\"\"Wrapper for the OMX interface to write from Emme matrices and numpy arrays. Write from Emmebank or Matrix Cache to OMX file, or read from OMX to Numpy. Also supports with statement. Args: file_path: path of OMX file mode: \"r\", \"w\" or \"a\" scenario: Emme scenario object for zone system and reference Emmebank omx_key: \"ID_NAME\", \"NAME\", \"ID\", format for generating OMX key from Emme matrix data matrix_cache: optional, Matrix Cache to support write data from cache (instead of always reading from Emmmebank) mask_max_value: optional, max value above which to write zero instead (\"big to zero\" behavior) \"\"\" def __init__ ( self , file_path : str , mode : str = \"r\" , scenario : EmmeScenario = None , omx_key : str = \"NAME\" , matrix_cache : MatrixCache = None , mask_max_value : float = None , ): # pylint: disable=R0913 self . _file_path = file_path self . _mode = mode self . _scenario = scenario self . _omx_key = omx_key self . _mask_max_value = mask_max_value self . _omx_file = None self . _emme_matrix_cache = matrix_cache self . _read_cache = {} def _generate_name ( self , matrix : EmmeMatrix ) -> str : if self . _omx_key == \"ID_NAME\" : return f \" { matrix . id } _ { matrix . name } \" if self . _omx_key == \"NAME\" : return matrix . name if self . _omx_key == \"ID\" : return matrix . id raise Exception ( f \"invalid omx_key: { self . _omx_key } \" ) def open ( self ): \"\"\"Open the OMX file.\"\"\" self . _omx_file = _omx . open_file ( self . _file_path , self . _mode ) def close ( self ): \"\"\"Close the OMX file.\"\"\" if self . _omx_file is not None : self . _omx_file . close () self . _omx_file = None self . _read_cache = {} def __enter__ ( self ): self . open () if self . _mode in [ \"a\" , \"w\" ] and self . _scenario is not None : try : self . _omx_file . create_mapping ( \"zone_number\" , self . _scenario . zone_numbers ) except LookupError : pass return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . close () def write_matrices ( self , matrices : List [ Union [ EmmeMatrix , str ]]): \"\"\"Write the list of emme matrices to OMX file. Args: matrices: list of Emme matrix objects or names / IDs of matrices in Emmebank, or dictionary of name: Emme matrix object/ Emme matrix ID \"\"\" if isinstance ( matrices , dict ): for key , matrix in matrices . items (): self . write_matrix ( matrix , key ) else : for matrix in matrices : self . write_matrix ( matrix ) def write_matrix ( self , matrix : [ str , EmmeMatrix ], name = None ): \"\"\"Write Emme matrix (as name or ID or Emme matrix object). Args: matrix: Emme matrix object or name / ID of matrix in Emmebank name: optional name to use for OMX key, if not specified the omx_key format will be used to generate a name from the Emme matrix data \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) if isinstance ( matrix , str ): matrix = self . _scenario . emmebank . matrix ( matrix ) if name is None : name = self . _generate_name ( matrix ) if self . _emme_matrix_cache : numpy_array = self . _emme_matrix_cache . get_data ( matrix ) else : numpy_array = matrix . get_numpy_data ( self . _scenario . id ) if matrix . type == \"DESTINATION\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( 1 , n_zones )) elif matrix . type == \"ORIGIN\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( n_zones , 1 )) attrs = { \"description\" : matrix . description } self . write_array ( numpy_array , name , attrs ) def write_clipped_array ( self , numpy_array : NumpyArray , name : str , a_min : float , a_max : float = None , attrs : Dict [ str , str ] = None , ): # pylint: disable=R0913 \"\"\"Write array with min and max values capped. Args: numpy_array: Numpy array name: name to use for the OMX key a_min: minimum value to clip array data a_max: optional maximum value to clip array data attrs: additional attribute key value pairs to write to OMX file \"\"\" if a_max is not None : numpy_array = numpy_array . clip ( a_min , a_max ) else : numpy_array = numpy_array . clip ( a_min ) self . write_array ( numpy_array , name , attrs ) def write_array ( self , numpy_array : NumpyArray , name : str , attrs : Dict [ str , str ] = None ): \"\"\"Write array with name and optional attrs to OMX file. Args: numpy_array:: Numpy array name: name to use for the OMX key attrs: additional attribute key value pairs to write to OMX file \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) shape = numpy_array . shape if len ( shape ) == 2 : chunkshape = ( 1 , shape [ 0 ]) else : chunkshape = None if self . _mask_max_value : numpy_array [ numpy_array > self . _mask_max_value ] = 0 numpy_array = numpy_array . astype ( dtype = \"float64\" , copy = False ) self . _omx_file . create_matrix ( name , obj = numpy_array , chunkshape = chunkshape , attrs = attrs ) def read ( self , name : str ) -> NumpyArray : \"\"\"Read OMX data as numpy array (standard interface). Caches matrix data (arrays) already read from disk. Args: name: name of OMX matrix Returns: Numpy array from OMX file \"\"\" if name in self . _read_cache : return self . _read_cache [ name ] data = self . _omx_file [ name ] . read () self . _read_cache [ name ] = data return data def read_hdf5 ( self , path : str ) -> NumpyArray : \"\"\"Read data directly from PyTables interface. Support for hdf5 formats that don't have full OMX compatibility. Args: path: hdf5 reference path to matrix data Returns: Numpy array from OMX file \"\"\" return self . _omx_file . get_node ( path ) . read () close ( self ) \u00b6 Close the OMX file. Source code in tm2py/emme/matrix.py def close ( self ): \"\"\"Close the OMX file.\"\"\" if self . _omx_file is not None : self . _omx_file . close () self . _omx_file = None self . _read_cache = {} open ( self ) \u00b6 Open the OMX file. Source code in tm2py/emme/matrix.py def open ( self ): \"\"\"Open the OMX file.\"\"\" self . _omx_file = _omx . open_file ( self . _file_path , self . _mode ) read ( self , name ) \u00b6 Read OMX data as numpy array (standard interface). Caches matrix data (arrays) already read from disk. Parameters: Name Type Description Default name str name of OMX matrix required Returns: Type Description <built-in function array> Numpy array from OMX file Source code in tm2py/emme/matrix.py def read ( self , name : str ) -> NumpyArray : \"\"\"Read OMX data as numpy array (standard interface). Caches matrix data (arrays) already read from disk. Args: name: name of OMX matrix Returns: Numpy array from OMX file \"\"\" if name in self . _read_cache : return self . _read_cache [ name ] data = self . _omx_file [ name ] . read () self . _read_cache [ name ] = data return data read_hdf5 ( self , path ) \u00b6 Read data directly from PyTables interface. Support for hdf5 formats that don\u2019t have full OMX compatibility. Parameters: Name Type Description Default path str hdf5 reference path to matrix data required Returns: Type Description <built-in function array> Numpy array from OMX file Source code in tm2py/emme/matrix.py def read_hdf5 ( self , path : str ) -> NumpyArray : \"\"\"Read data directly from PyTables interface. Support for hdf5 formats that don't have full OMX compatibility. Args: path: hdf5 reference path to matrix data Returns: Numpy array from OMX file \"\"\" return self . _omx_file . get_node ( path ) . read () write_array ( self , numpy_array , name , attrs = None ) \u00b6 Write array with name and optional attrs to OMX file. Parameters: Name Type Description Default numpy_array <built-in function array> : Numpy array required name str name to use for the OMX key required attrs Dict[str, str] additional attribute key value pairs to write to OMX file None Source code in tm2py/emme/matrix.py def write_array ( self , numpy_array : NumpyArray , name : str , attrs : Dict [ str , str ] = None ): \"\"\"Write array with name and optional attrs to OMX file. Args: numpy_array:: Numpy array name: name to use for the OMX key attrs: additional attribute key value pairs to write to OMX file \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) shape = numpy_array . shape if len ( shape ) == 2 : chunkshape = ( 1 , shape [ 0 ]) else : chunkshape = None if self . _mask_max_value : numpy_array [ numpy_array > self . _mask_max_value ] = 0 numpy_array = numpy_array . astype ( dtype = \"float64\" , copy = False ) self . _omx_file . create_matrix ( name , obj = numpy_array , chunkshape = chunkshape , attrs = attrs ) write_clipped_array ( self , numpy_array , name , a_min , a_max = None , attrs = None ) \u00b6 Write array with min and max values capped. Parameters: Name Type Description Default numpy_array <built-in function array> Numpy array required name str name to use for the OMX key required a_min float minimum value to clip array data required a_max float optional maximum value to clip array data None attrs Dict[str, str] additional attribute key value pairs to write to OMX file None Source code in tm2py/emme/matrix.py def write_clipped_array ( self , numpy_array : NumpyArray , name : str , a_min : float , a_max : float = None , attrs : Dict [ str , str ] = None , ): # pylint: disable=R0913 \"\"\"Write array with min and max values capped. Args: numpy_array: Numpy array name: name to use for the OMX key a_min: minimum value to clip array data a_max: optional maximum value to clip array data attrs: additional attribute key value pairs to write to OMX file \"\"\" if a_max is not None : numpy_array = numpy_array . clip ( a_min , a_max ) else : numpy_array = numpy_array . clip ( a_min ) self . write_array ( numpy_array , name , attrs ) write_matrices ( self , matrices ) \u00b6 Write the list of emme matrices to OMX file. Parameters: Name Type Description Default matrices List[Union[<MagicMock name='mock.Matrix' id='140339788665808'>, str]] list of Emme matrix objects or names / IDs of matrices in Emmebank, or dictionary of name: Emme matrix object/ Emme matrix ID required Source code in tm2py/emme/matrix.py def write_matrices ( self , matrices : List [ Union [ EmmeMatrix , str ]]): \"\"\"Write the list of emme matrices to OMX file. Args: matrices: list of Emme matrix objects or names / IDs of matrices in Emmebank, or dictionary of name: Emme matrix object/ Emme matrix ID \"\"\" if isinstance ( matrices , dict ): for key , matrix in matrices . items (): self . write_matrix ( matrix , key ) else : for matrix in matrices : self . write_matrix ( matrix ) write_matrix ( self , matrix , name = None ) \u00b6 Write Emme matrix (as name or ID or Emme matrix object). Parameters: Name Type Description Default matrix [<class 'str'>, <MagicMock name='mock.Matrix' id='140339788665808'>] Emme matrix object or name / ID of matrix in Emmebank required name optional name to use for OMX key, if not specified the omx_key format will be used to generate a name from the Emme matrix data None Source code in tm2py/emme/matrix.py def write_matrix ( self , matrix : [ str , EmmeMatrix ], name = None ): \"\"\"Write Emme matrix (as name or ID or Emme matrix object). Args: matrix: Emme matrix object or name / ID of matrix in Emmebank name: optional name to use for OMX key, if not specified the omx_key format will be used to generate a name from the Emme matrix data \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) if isinstance ( matrix , str ): matrix = self . _scenario . emmebank . matrix ( matrix ) if name is None : name = self . _generate_name ( matrix ) if self . _emme_matrix_cache : numpy_array = self . _emme_matrix_cache . get_data ( matrix ) else : numpy_array = matrix . get_numpy_data ( self . _scenario . id ) if matrix . type == \"DESTINATION\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( 1 , n_zones )) elif matrix . type == \"ORIGIN\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( n_zones , 1 )) attrs = { \"description\" : matrix . description } self . write_array ( numpy_array , name , attrs ) network \u00b6 Module for Emme network calculations. Contains NetworkCalculator class to generate Emme format specifications for the Network calculator. NetworkCalculator \u00b6 Simple wrapper interface to the Emme Network calculator Used to generate the standard network calculator specification (dictionary) from argument inputs. Useful when NOT (commonly) using selection or aggregation options, and mostly running link expression calculations Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object required Source code in tm2py/emme/network.py class NetworkCalculator : \"\"\"Simple wrapper interface to the Emme Network calculator Used to generate the standard network calculator specification (dictionary) from argument inputs. Useful when NOT (commonly) using selection or aggregation options, and mostly running link expression calculations Args: scenario: Emme scenario object \"\"\" def __init__ ( self , scenario : EmmeScenario ): self . _scenario = scenario emme_manager = _manager . EmmeManager () modeller = emme_manager . modeller () self . _network_calc = modeller . tool ( \"inro.emme.network_calculation.network_calculator\" ) self . _specs = [] def __call__ ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ) -> Dict [ str , float ]: \"\"\"Run a network calculation in the scenario, see the Emme help for more. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. Returns: A dictionary report with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" spec = self . _format_spec ( result , expression , selections , aggregation ) return self . _network_calc ( spec , self . _scenario ) def add_calc ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ): \"\"\"Add calculation to list of network calculations to run. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. \"\"\" self . _specs . append ( self . _format_spec ( result , expression , selections , aggregation ) ) def run ( self ) -> List [ Dict [ str , float ]]: \"\"\"Run accumulated network calculations all at once. Returns: A list of dictionary reports with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" reports = self . _network_calc ( self . _specs , self . _scenario ) self . _specs = [] return reports @staticmethod def _format_spec ( result : str , expression : str , selections : Union [ str , Dict [ str , str ]], aggregation : Dict [ str , str ], ) -> EmmeNetworkCalcSpecification : spec = { \"result\" : result , \"expression\" : expression , \"aggregation\" : aggregation , \"type\" : \"NETWORK_CALCULATION\" , } if selections is not None : if isinstance ( selections , str ): selections = { \"link\" : selections } spec [ \"selections\" ] = selections else : spec [ \"selections\" ] = { \"link\" : \"all\" } return spec __call__ ( self , result , expression , selections = None , aggregation = None ) special \u00b6 Run a network calculation in the scenario, see the Emme help for more. Parameters: Name Type Description Default result str Name of network attribute required expression str Calculation expression required selections Union[str, Dict[str, str]] Selection expression nest. Defaults to {\u201clink\u201d: \u201call\u201d} if not specified, and is used as a link selection expression if specified as a string. None aggregation Dict[str, str] Aggregation operators if aggregating between network domains. None Returns: Type Description Dict[str, float] A dictionary report with min, max, average and sum of the calculation expression. See Emme help \u2018Network calculator\u2019 for more. Source code in tm2py/emme/network.py def __call__ ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ) -> Dict [ str , float ]: \"\"\"Run a network calculation in the scenario, see the Emme help for more. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. Returns: A dictionary report with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" spec = self . _format_spec ( result , expression , selections , aggregation ) return self . _network_calc ( spec , self . _scenario ) add_calc ( self , result , expression , selections = None , aggregation = None ) \u00b6 Add calculation to list of network calculations to run. Parameters: Name Type Description Default result str Name of network attribute required expression str Calculation expression required selections Union[str, Dict[str, str]] Selection expression nest. Defaults to {\u201clink\u201d: \u201call\u201d} if not specified, and is used as a link selection expression if specified as a string. None aggregation Dict[str, str] Aggregation operators if aggregating between network domains. None Source code in tm2py/emme/network.py def add_calc ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ): \"\"\"Add calculation to list of network calculations to run. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. \"\"\" self . _specs . append ( self . _format_spec ( result , expression , selections , aggregation ) ) run ( self ) \u00b6 Run accumulated network calculations all at once. Returns: Type Description List[Dict[str, float]] A list of dictionary reports with min, max, average and sum of the calculation expression. See Emme help \u2018Network calculator\u2019 for more. Source code in tm2py/emme/network.py def run ( self ) -> List [ Dict [ str , float ]]: \"\"\"Run accumulated network calculations all at once. Returns: A list of dictionary reports with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" reports = self . _network_calc ( self . _specs , self . _scenario ) self . _specs = [] return reports Errata \u00b6 tm2py.logger \u00b6 Logging module LogStartEnd \u00b6 Log the start and end time with optional message. Used as a Component method decorator. If msg is not provided a default message is generated with the object class and method name. Parameters: Name Type Description Default msg str message text to use in the start and end record None level str logging level 'INFO' Source code in tm2py/logger.py class LogStartEnd : \"\"\"Log the start and end time with optional message. Used as a Component method decorator. If msg is not provided a default message is generated with the object class and method name. Args: msg (str): message text to use in the start and end record level (str): logging level \"\"\" def __init__ ( self , msg : str = None , level : str = \"INFO\" ): self . msg = msg self . level = level def __call__ ( self , func ): @functools . wraps ( func ) def wrapper ( obj , * args , ** kwargs ): msg = self . msg or obj . __class__ . __name__ + \" \" + func . __name__ obj . logger . log_start ( msg , self . level ) value = func ( obj , * args , ** kwargs ) obj . logger . log_end ( msg , self . level ) return value return wrapper Logger \u00b6 Logger Source code in tm2py/logger.py class Logger : \"\"\"Logger\"\"\" def __init__ ( self , controller ): super () . __init__ () self . _controller = controller self . _indentation = 0 @staticmethod def log ( text : str , level : str = \"INFO\" ): \"\"\"Placeholder logging method Args: text (str): text to log level (str): logging level of the message text \"\"\" if level : print ( text ) def log_time ( self , msg : str , level : str = \"INFO\" , indent : bool = True ): \"\"\"Log message with timestamp Args: msg (str): message text level (str): logging level indent (bool): if true indent any messages based on the number of open contexts \"\"\" timestamp = datetime . now () . strftime ( \" %d -%b-%Y (%H:%M:%S)\" ) if indent : indent = \" \" * self . _indentation self . log ( f \" { timestamp } : { indent }{ msg } \" , level ) else : self . log ( f \" { timestamp } : { msg } \" , level ) def log_start ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'Start'. Args: msg (str): message text level (str): logging level \"\"\" self . log_time ( f \"Start { msg } \" , level , indent = True ) self . _indentation += 1 def log_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'End'. Args: msg (str): message text level (str): logging level \"\"\" self . _indentation -= 1 self . log_time ( f \"End { msg } \" , level , indent = True ) @_context def log_start_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Use with 'with' statement to log the start and end time with message. Args: msg (str): message text level (str): logging level \"\"\" self . log_start ( msg , level ) yield self . log_end ( msg , level ) log ( text , level = 'INFO' ) staticmethod \u00b6 Placeholder logging method Parameters: Name Type Description Default text str text to log required level str logging level of the message text 'INFO' Source code in tm2py/logger.py @staticmethod def log ( text : str , level : str = \"INFO\" ): \"\"\"Placeholder logging method Args: text (str): text to log level (str): logging level of the message text \"\"\" if level : print ( text ) log_end ( self , msg , level = 'INFO' ) \u00b6 Log message with timestamp and \u2018End\u2019. Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' Source code in tm2py/logger.py def log_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'End'. Args: msg (str): message text level (str): logging level \"\"\" self . _indentation -= 1 self . log_time ( f \"End { msg } \" , level , indent = True ) log_start ( self , msg , level = 'INFO' ) \u00b6 Log message with timestamp and \u2018Start\u2019. Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' Source code in tm2py/logger.py def log_start ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'Start'. Args: msg (str): message text level (str): logging level \"\"\" self . log_time ( f \"Start { msg } \" , level , indent = True ) self . _indentation += 1 log_start_end ( self , msg , level = 'INFO' ) \u00b6 Use with \u2018with\u2019 statement to log the start and end time with message. Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' Source code in tm2py/logger.py @_context def log_start_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Use with 'with' statement to log the start and end time with message. Args: msg (str): message text level (str): logging level \"\"\" self . log_start ( msg , level ) yield self . log_end ( msg , level ) log_time ( self , msg , level = 'INFO' , indent = True ) \u00b6 Log message with timestamp Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' indent bool if true indent any messages based on the number of open contexts True Source code in tm2py/logger.py def log_time ( self , msg : str , level : str = \"INFO\" , indent : bool = True ): \"\"\"Log message with timestamp Args: msg (str): message text level (str): logging level indent (bool): if true indent any messages based on the number of open contexts \"\"\" timestamp = datetime . now () . strftime ( \" %d -%b-%Y (%H:%M:%S)\" ) if indent : indent = \" \" * self . _indentation self . log ( f \" { timestamp } : { indent }{ msg } \" , level ) else : self . log ( f \" { timestamp } : { msg } \" , level ) tm2py.tools \u00b6 Tools module for common resources / shared code and \u201cutilities\u201d in the tm2py package. download_unzip ( url , out_base_dir , target_dir , zip_filename = 'test_data.zip' ) \u00b6 Downloads and unzips a file from a URL. The zip file is removed after extraction. Parameters: Name Type Description Default url str Full URL do download from. required out_base_dir str Where to unzip the file. required target_dir str What to unzip the file as. required zip_filename str Filename to store zip file as. Defaults to \u201ctest_data.zip\u201d. 'test_data.zip' Source code in tm2py/tools.py def download_unzip ( url : str , out_base_dir : str , target_dir : str , zip_filename : str = \"test_data.zip\" ) -> None : \"\"\"Downloads and unzips a file from a URL. The zip file is removed after extraction. Args: url (str): Full URL do download from. out_base_dir (str): Where to unzip the file. target_dir (str): What to unzip the file as. zip_filename (str, optional): Filename to store zip file as. Defaults to \"test_data.zip\". \"\"\" target_zip = os . path . join ( out_base_dir , zip_filename ) if not os . path . isdir ( out_base_dir ): os . makedirs ( out_base_dir ) urllib . request . Request ( url ) _download ( url , target_zip ) _unzip ( target_zip , target_dir ) os . remove ( target_zip ) parse_num_processors ( value ) \u00b6 Convert input value (parse if string) to number of processors. Parameters: Name Type Description Default value Union[str, int, float] an int, float or string; string value can be \u201cX\u201d or \u201cMAX-X\u201d required Returns: Type Description An int of the number of processors to use Exceptions: Type Description Exception Input value exceeds number of available processors Exception Input value less than 1 processors Source code in tm2py/tools.py def parse_num_processors ( value : Union [ str , int , float ]): \"\"\"Convert input value (parse if string) to number of processors. Args: value: an int, float or string; string value can be \"X\" or \"MAX-X\" Returns: An int of the number of processors to use Raises: Exception: Input value exceeds number of available processors Exception: Input value less than 1 processors \"\"\" max_processors = multiprocessing . cpu_count () if isinstance ( value , str ): result = value . upper () if result == \"MAX\" : return max_processors if re . match ( \"^[0-9]+$\" , value ): return int ( value ) result = re . split ( r \"^MAX[\\s]*-[\\s]*\" , result ) if len ( result ) == 2 : return max ( max_processors - int ( result [ 1 ]), 1 ) raise Exception ( f \"Input value { value } is an int or string as 'MAX-X'\" ) result = int ( value ) if result > max_processors : raise Exception ( f \"Input value { value } greater than available processors\" ) if result < 1 : raise Exception ( f \"Input value { value } less than 1 processors\" ) return value tm2py.examples \u00b6 Download and unzip examples for tm2py, used in tests get_example ( example_name = 'UnionCity' , example_subdir = 'examples' , root_dir = '..' , retrieval_url = 'https://mtcdrive.box.com/shared/static/3entr016e9teq2wt46x1os3fjqylfoge.zip' ) \u00b6 Returns example directory; downloads if necessary from retrieval URL. Parameters: Name Type Description Default example_name str Used to retrieve sub-folder or create it if doesn\u2019t exist. Defaults to _DEFAULT_EXAMPLE_NAME. 'UnionCity' example_subdir str Where to find examples within root dir. Defaults to _DEFAULT_EXAMPLE_SUBDIR. 'examples' root_dir str Root dir of project. Defaults to _ROOT_DIR. '..' retrieval_url str URL to retrieve example data zip from. Defaults to _DEFAULT_EXAMPLE_URL. 'https://mtcdrive.box.com/shared/static/3entr016e9teq2wt46x1os3fjqylfoge.zip' Exceptions: Type Description FileNotFoundError If can\u2019t find the files after trying to download it. Returns: Type Description str Path to example data. Source code in tm2py/examples.py def get_example ( example_name : str = _DEFAULT_EXAMPLE_NAME , example_subdir : str = _DEFAULT_EXAMPLE_SUBDIR , root_dir : str = _ROOT_DIR , retrieval_url : str = _DEFAULT_EXAMPLE_URL , ) -> str : \"\"\"Returns example directory; downloads if necessary from retrieval URL. Args: example_name (str, optional): Used to retrieve sub-folder or create it if doesn't exist. Defaults to _DEFAULT_EXAMPLE_NAME. example_subdir (str, optional): Where to find examples within root dir. Defaults to _DEFAULT_EXAMPLE_SUBDIR. root_dir (str, optional): Root dir of project. Defaults to _ROOT_DIR. retrieval_url (str, optional): URL to retrieve example data zip from. Defaults to _DEFAULT_EXAMPLE_URL. Raises: FileNotFoundError: If can't find the files after trying to download it. Returns: str: Path to example data. \"\"\" _example_dir = os . path . join ( root_dir , example_subdir ) _this_example_dir = os . path . join ( _example_dir , example_name ) if os . path . isdir ( _this_example_dir ): return _this_example_dir download_unzip ( retrieval_url , _example_dir , _this_example_dir ) if not os . path . isdir ( _this_example_dir ): raise FileNotFoundError ( f \"example { _this_example_dir } not found\" ) return _this_example_dir","title":"API Documentation"},{"location":"api/#api-documentation","text":"","title":"API Documentation"},{"location":"api/#controller","text":"","title":"Controller"},{"location":"api/#tm2py.controller","text":"RunController - model operation controller. Main interface to start a TM2PY model run. Provide one or more configuration files in .toml format (by convention a scenario.toml and a model.toml) Typical usage example: from tm2py.controller import RunController controller = RunController( [r\u201dexample_union\\scenario.toml\u201d, r\u201dexample_union\\model.toml\u201d]) controller.run() Or from the command-line: python \\tm2py\\tm2py\\controller.py \u2013s scenario.toml \u2013m model.toml","title":"controller"},{"location":"api/#tm2py.controller.RunController","text":"Main operational interface for model runs. Provide one or more config files in TOML (*.toml) format, and a run directory. If the run directory is not provided the root directory of the first config_file is used. Properties config: root Configuration object logger: logger object top_sheet: placeholder for top sheet functionality (not implemented yet) trace: placeholder for trace functionality (not implemented yet) run_dir: root run directory for the model run iteration: current running (or last started) iteration component: current running (or last started) Component object EmmeManager object for centralized Emme-related (highway and transit assignments and skims) utilities. list of components which have completed, tuple of (iteration, name, Component object) Source code in tm2py/controller.py class RunController : \"\"\"Main operational interface for model runs. Provide one or more config files in TOML (*.toml) format, and a run directory. If the run directory is not provided the root directory of the first config_file is used. Properties: config: root Configuration object logger: logger object top_sheet: placeholder for top sheet functionality (not implemented yet) trace: placeholder for trace functionality (not implemented yet) run_dir: root run directory for the model run iteration: current running (or last started) iteration component: current running (or last started) Component object emme_manager: EmmeManager object for centralized Emme-related (highway and transit assignments and skims) utilities. complete_components: list of components which have completed, tuple of (iteration, name, Component object) \"\"\" def __init__ ( self , config_file : Union [ List [ str ], str ] = None , run_dir : str = None ): if not isinstance ( config_file , list ): config_file = [ config_file ] if run_dir is None : run_dir = os . path . abspath ( os . path . dirname ( config_file [ 0 ])) self . _run_dir = run_dir self . config = Configuration . load_toml ( config_file ) self . logger = Logger ( self ) self . top_sheet = None self . trace = None self . completed_components = [] # mapping from defined names referenced in config to Component objects self . _component_map = { k : v ( self ) for k , v in component_cls_map . items ()} self . _emme_manager = None self . _iteration = None self . _component = None self . _queued_components = [] self . _queue_components () @property def run_dir ( self ) -> str : \"\"\"The root run directory of the model run\"\"\" return self . _run_dir @property def iteration ( self ) -> int : \"\"\"Current iteration of model\"\"\" return self . _iteration @property def component ( self ) -> Component : \"\"\"Current component of model\"\"\" return self . _component @property def emme_manager ( self ) -> EmmeManager : \"\"\"Cached Emme Manager object\"\"\" if self . _emme_manager is None : self . _init_emme_manager () return self . _emme_manager def _init_emme_manager ( self ): \"\"\"Initialize Emme manager, start Emme desktop App, and initialize Modeller\"\"\" self . _emme_manager = EmmeManager () project = self . _emme_manager . project ( os . path . join ( self . run_dir , self . config . emme . project_path ) ) # Initialize Modeller to use Emme assignment tools and other APIs self . _emme_manager . modeller ( project ) def run ( self ): \"\"\"Main interface to run model\"\"\" self . _iteration = None self . validate_inputs () for iteration , name , component in self . _queued_components : if self . _iteration != iteration : self . logger . log_time ( f \"Start iteration { iteration } \" ) self . _iteration = iteration self . _component = component component . run () self . completed_components . append (( iteration , name , component )) def _queue_components ( self ): \"\"\"Add components per iteration to queue according to input Config\"\"\" self . _queued_components = [] if self . config . run . start_iteration == 0 : self . _queued_components += [ ( 0 , c_name , self . _component_map [ c_name ]) for c_name in self . config . run . initial_components ] iteration_nums = range ( max ( 1 , self . config . run . start_iteration ), self . config . run . end_iteration + 1 ) iteration_components = [ self . _component_map [ c_name ] for c_name in self . config . run . global_iteration_components ] self . _queued_components += list ( itertools . product ( iteration_nums , iteration_components , self . config . run . global_iteration_components , ) ) self . _queued_components += [ ( self . config . run . end_iteration + 1 , self . _component_map [ c_name ]) for c_name in self . config . run . final_components ] if self . config . run . start_component : start_index = [ idx for idx , c in enumerate ( self . _queued_components ) if self . config . run . start_component == c [ 1 ] ][ 0 ] self . _queued_components = self . _queued_components [ start_index :] def validate_inputs ( self ): \"\"\"Validate input state prior to run\"\"\" already_validated_components = set () for _ , name , component in self . _queued_components : if name not in already_validated_components : component . validate_inputs () already_validated_components . add ( name )","title":"RunController"},{"location":"api/#tm2py.controller.RunController.component","text":"Current component of model","title":"component"},{"location":"api/#tm2py.controller.RunController.emme_manager","text":"Cached Emme Manager object","title":"emme_manager"},{"location":"api/#tm2py.controller.RunController.iteration","text":"Current iteration of model","title":"iteration"},{"location":"api/#tm2py.controller.RunController.run_dir","text":"The root run directory of the model run","title":"run_dir"},{"location":"api/#tm2py.controller.RunController.run","text":"Main interface to run model Source code in tm2py/controller.py def run ( self ): \"\"\"Main interface to run model\"\"\" self . _iteration = None self . validate_inputs () for iteration , name , component in self . _queued_components : if self . _iteration != iteration : self . logger . log_time ( f \"Start iteration { iteration } \" ) self . _iteration = iteration self . _component = component component . run () self . completed_components . append (( iteration , name , component ))","title":"run()"},{"location":"api/#tm2py.controller.RunController.validate_inputs","text":"Validate input state prior to run Source code in tm2py/controller.py def validate_inputs ( self ): \"\"\"Validate input state prior to run\"\"\" already_validated_components = set () for _ , name , component in self . _queued_components : if name not in already_validated_components : component . validate_inputs () already_validated_components . add ( name )","title":"validate_inputs()"},{"location":"api/#components","text":"","title":"Components"},{"location":"api/#base-component","text":"","title":"Base Component"},{"location":"api/#tm2py.components.component","text":"Root component ABC","title":"component"},{"location":"api/#tm2py.components.component.Component","text":"Base component class for tm2py top-level inheritance. Examples: :: class MyComponent(Component): 1 2 3 4 5 6 7 8 9 10 11 12 13 def __init__(self, controller): super().__init__(controller) self._parameter = None def run(self): self._step1() self._step2() def _step1(self): pass def _step2(self): pass Source code in tm2py/components/component.py class Component ( ABC ): \"\"\"Base component class for tm2py top-level inheritance. Example: :: class MyComponent(Component): def __init__(self, controller): super().__init__(controller) self._parameter = None def run(self): self._step1() self._step2() def _step1(self): pass def _step2(self): pass \"\"\" def __init__ ( self , controller : RunController ): self . _controller = controller self . _trace = None @property def controller ( self ): \"\"\"Parent controller\"\"\" return self . _controller def get_abs_path ( self , rel_path : str ): \"\"\"Get the absolute path from the root run directory given a relative path.\"\"\" return os . path . join ( self . controller . run_dir , rel_path ) def get_emme_scenario ( self , emmebank_path : str , time_period : str ) -> EmmeScenario : \"\"\"Get the Emme scenario object from the Emmebank at emmebank_path for the time_period ID. Args: emmebank_path: valid Emmebank path, absolute or relative to root run directory time_period: valid time_period ID Returns Emme Scenario object (see Emme API Reference) \"\"\" if not os . path . isabs ( emmebank_path ): emmebank_path = self . get_abs_path ( emmebank_path ) emmebank = self . controller . emme_manager . emmebank ( emmebank_path ) scenario_id = { tp . name : tp . emme_scenario_id for tp in self . config . time_periods }[ time_period ] return emmebank . scenario ( scenario_id ) @property def config ( self ): \"\"\"Configuration settings loaded from config files\"\"\" return self . controller . config @property def top_sheet ( self ): \"\"\"docstring placeholder for top sheet\"\"\" return self . controller . top_sheet @property def logger ( self ): \"\"\"docstring placeholder for logger\"\"\" return self . controller . logger @property def trace ( self ): \"\"\"docstring placeholder for trace\"\"\" return self . _trace def validate_inputs ( self ): \"\"\"Validate inputs are correct at model initiation, fail fast if not\"\"\" @abstractmethod def run ( self ): \"\"\"Run model component\"\"\" def report_progress ( self ): \"\"\"Write progress to log file\"\"\" def test_component ( self ): \"\"\"Run stand-alone component test\"\"\" def write_top_sheet ( self ): \"\"\"Write key outputs to the model top sheet\"\"\" def verify ( self ): \"\"\"Verify component outputs / results\"\"\" def time_period_names ( self ) -> List [ str ]: \"\"\"Return input time_period name or names and return list of time_period names. Returns: list of string names of time periods \"\"\" return [ time . name for time in self . config . time_periods ]","title":"Component"},{"location":"api/#tm2py.components.component.Component.config","text":"Configuration settings loaded from config files","title":"config"},{"location":"api/#tm2py.components.component.Component.controller","text":"Parent controller","title":"controller"},{"location":"api/#tm2py.components.component.Component.logger","text":"docstring placeholder for logger","title":"logger"},{"location":"api/#tm2py.components.component.Component.top_sheet","text":"docstring placeholder for top sheet","title":"top_sheet"},{"location":"api/#tm2py.components.component.Component.trace","text":"docstring placeholder for trace","title":"trace"},{"location":"api/#tm2py.components.component.Component.get_abs_path","text":"Get the absolute path from the root run directory given a relative path. Source code in tm2py/components/component.py def get_abs_path ( self , rel_path : str ): \"\"\"Get the absolute path from the root run directory given a relative path.\"\"\" return os . path . join ( self . controller . run_dir , rel_path )","title":"get_abs_path()"},{"location":"api/#tm2py.components.component.Component.get_emme_scenario","text":"Get the Emme scenario object from the Emmebank at emmebank_path for the time_period ID. Parameters: Name Type Description Default emmebank_path str valid Emmebank path, absolute or relative to root run directory required time_period str valid time_period ID required Returns Emme Scenario object (see Emme API Reference) Source code in tm2py/components/component.py def get_emme_scenario ( self , emmebank_path : str , time_period : str ) -> EmmeScenario : \"\"\"Get the Emme scenario object from the Emmebank at emmebank_path for the time_period ID. Args: emmebank_path: valid Emmebank path, absolute or relative to root run directory time_period: valid time_period ID Returns Emme Scenario object (see Emme API Reference) \"\"\" if not os . path . isabs ( emmebank_path ): emmebank_path = self . get_abs_path ( emmebank_path ) emmebank = self . controller . emme_manager . emmebank ( emmebank_path ) scenario_id = { tp . name : tp . emme_scenario_id for tp in self . config . time_periods }[ time_period ] return emmebank . scenario ( scenario_id )","title":"get_emme_scenario()"},{"location":"api/#tm2py.components.component.Component.report_progress","text":"Write progress to log file Source code in tm2py/components/component.py def report_progress ( self ): \"\"\"Write progress to log file\"\"\"","title":"report_progress()"},{"location":"api/#tm2py.components.component.Component.run","text":"Run model component Source code in tm2py/components/component.py @abstractmethod def run ( self ): \"\"\"Run model component\"\"\"","title":"run()"},{"location":"api/#tm2py.components.component.Component.test_component","text":"Run stand-alone component test Source code in tm2py/components/component.py def test_component ( self ): \"\"\"Run stand-alone component test\"\"\"","title":"test_component()"},{"location":"api/#tm2py.components.component.Component.time_period_names","text":"Return input time_period name or names and return list of time_period names. Returns: list of string names of time periods Source code in tm2py/components/component.py def time_period_names ( self ) -> List [ str ]: \"\"\"Return input time_period name or names and return list of time_period names. Returns: list of string names of time periods \"\"\" return [ time . name for time in self . config . time_periods ]","title":"time_period_names()"},{"location":"api/#tm2py.components.component.Component.validate_inputs","text":"Validate inputs are correct at model initiation, fail fast if not Source code in tm2py/components/component.py def validate_inputs ( self ): \"\"\"Validate inputs are correct at model initiation, fail fast if not\"\"\"","title":"validate_inputs()"},{"location":"api/#tm2py.components.component.Component.verify","text":"Verify component outputs / results Source code in tm2py/components/component.py def verify ( self ): \"\"\"Verify component outputs / results\"\"\"","title":"verify()"},{"location":"api/#tm2py.components.component.Component.write_top_sheet","text":"Write key outputs to the model top sheet Source code in tm2py/components/component.py def write_top_sheet ( self ): \"\"\"Write key outputs to the model top sheet\"\"\"","title":"write_top_sheet()"},{"location":"api/#demand-components","text":"","title":"Demand Components"},{"location":"api/#tm2py.components.demand","text":"Demand components module","title":"demand"},{"location":"api/#tm2py.components.demand.demand","text":"Demand loading from OMX to Emme database","title":"demand"},{"location":"api/#tm2py.components.demand.demand.PrepareDemand","text":"Abstract base class to import and average demand. Source code in tm2py/components/demand/demand.py class PrepareDemand ( Component , ABC ): \"\"\"Abstract base class to import and average demand.\"\"\" def __init__ ( self , controller : RunController ): super () . __init__ ( controller ) self . _emmebank = None def _read ( self , path , name , num_zones , factor = None ): with OMXManager ( path , \"r\" ) as omx_file : demand = omx_file . read ( name ) if factor is not None : demand = factor * demand demand = self . _redim_demand ( demand , num_zones ) return demand @staticmethod def _redim_demand ( demand , num_zones ): _shape = demand . shape if _shape != ( num_zones , num_zones ): demand = np . pad ( demand , (( 0 , num_zones - _shape [ 0 ]), ( 0 , num_zones - _shape [ 1 ])) ) return demand # Disable too many arguments recommendation # pylint: disable=R0913 def _save_demand ( self , name , demand , scenario , description = \"\" , apply_msa = False ): matrix = self . _emmebank . matrix ( f 'mf\" { name } \"' ) msa_iteration = self . controller . iteration if not apply_msa or msa_iteration <= 1 : if not matrix : ident = self . _emmebank . available_matrix_identifier ( \"FULL\" ) matrix = self . _emmebank . create_matrix ( ident ) matrix . name = name matrix . description = description else : if not matrix : raise Exception ( f \"error averaging demand: matrix { name } does not exist\" ) prev_demand = matrix . get_numpy_data ( scenario . id ) demand = prev_demand + ( 1.0 / msa_iteration ) * ( demand - prev_demand ) matrix . set_numpy_data ( demand , scenario . id ) def _create_zero_matrix ( self ): zero_matrix = self . _emmebank . matrix ( 'ms\"zero\"' ) if zero_matrix is None : ident = self . _emmebank . available_matrix_identifier ( \"SCALAR\" ) zero_matrix = self . _emmebank . create_matrix ( ident ) zero_matrix . name = \"zero\" zero_matrix . description = \"zero demand matrix\" zero_matrix . data = 0","title":"PrepareDemand"},{"location":"api/#tm2py.components.demand.demand.PrepareHighwayDemand","text":"Import and average highway demand. Demand is imported from OMX files based on reference file paths and OMX matrix names in highway assignment config (highway.classes). The demand is average using MSA with the current demand matrices (in the Emmebank) if the controller.iteration > 1. Parameters: Name Type Description Default controller RunController parent RunController object required Source code in tm2py/components/demand/demand.py class PrepareHighwayDemand ( PrepareDemand ): \"\"\"Import and average highway demand. Demand is imported from OMX files based on reference file paths and OMX matrix names in highway assignment config (highway.classes). The demand is average using MSA with the current demand matrices (in the Emmebank) if the controller.iteration > 1. Args: controller: parent RunController object \"\"\" def __init__ ( self , controller : RunController ): super () . __init__ ( controller ) self . _emmebank_path = None # @LogStartEnd(\"prepare highway demand\") def run ( self ): \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\" self . _emmebank_path = self . get_abs_path ( self . config . emme . highway_database_path ) self . _emmebank = self . controller . emme_manager . emmebank ( self . _emmebank_path ) self . _create_zero_matrix () for time in self . time_period_names (): for klass in self . config . highway . classes : self . _prepare_demand ( klass . name , klass . description , klass . demand , time ) def _prepare_demand ( self , name : str , description : str , demand_config : List [ Dict [ str , Union [ str , float ]]], time_period : str , ): \"\"\"Load demand from OMX files and save to Emme matrix for highway assignment. Average with previous demand (MSA) if the current iteration > 1 Args: name (str): the name of the highway assignment class description (str): the description for the highway assignment class demand_config (dict): the list of file cross-reference(s) for the demand to be loaded {\"source\": <name of demand model component>, \"name\": <OMX key name>, \"factor\": <factor to apply to demand in this file>} time_period (str): the time time_period ID (name) \"\"\" scenario = self . get_emme_scenario ( self . _emmebank_path , time_period ) num_zones = len ( scenario . zone_numbers ) demand = self . _read_demand ( demand_config [ 0 ], time_period , num_zones ) for file_config in demand_config [ 1 :]: demand = demand + self . _read_demand ( file_config , time_period , num_zones ) demand_name = f \" { time_period } _ { name } \" description = f \" { time_period } { description } demand\" self . _save_demand ( demand_name , demand , scenario , description , apply_msa = True ) def _read_demand ( self , file_config , time_period , num_zones ): # Load demand from cross-referenced source file, # the named demand model component under the key highway_demand_file source = file_config [ \"source\" ] name = file_config [ \"name\" ] . format ( period = time_period . upper ()) factor = file_config . get ( \"factor\" ) path = self . get_abs_path ( self . config [ source ] . highway_demand_file ) return self . _read ( path . format ( period = time_period ), name , num_zones , factor )","title":"PrepareHighwayDemand"},{"location":"api/#tm2py.components.demand.demand.PrepareHighwayDemand.run","text":"Open combined demand OMX files from demand models and prepare for assignment. Source code in tm2py/components/demand/demand.py def run ( self ): \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\" self . _emmebank_path = self . get_abs_path ( self . config . emme . highway_database_path ) self . _emmebank = self . controller . emme_manager . emmebank ( self . _emmebank_path ) self . _create_zero_matrix () for time in self . time_period_names (): for klass in self . config . highway . classes : self . _prepare_demand ( klass . name , klass . description , klass . demand , time )","title":"run()"},{"location":"api/#network-components","text":"","title":"Network Components"},{"location":"api/#tm2py.components.network","text":"","title":"network"},{"location":"api/#tm2py.components.network.highway","text":"","title":"highway"},{"location":"api/#tm2py.components.network.highway.highway_assign","text":"Highway assignment and skim component. Performs equilibrium traffic assignment and generates resulting skims. The assignmend is configured using the \u201chighway\u201d table in the source config. See the config documentation for details. The traffic assignment runs according to the list of assignment classes under highway.classes. Other relevant parameters from the config are emme.num_processors: number of processors as integer or \u201cMAX\u201d or \u201cMAX-N\u201d time_periods[].emme_scenario_id: Emme scenario number to use for each period time_periods[].highway_capacity_factor The Emme network must have the following attributes available: Link: - \u201clength\u201d in feet - \u201cvdf\u201d, volume delay function (volume delay functions must also be setup) - \u201c@useclass\u201d, vehicle-class restrictions classification, auto-only, HOV only - \u201c@free_flow_time\u201d, the free flow time (in minutes) - \u201c@tollXX_YY\u201d, the toll for period XX and class subgroup (see truck class) named YY, used together with @tollbooth to generate @bridgetoll_YY and @valuetoll_YY - \u201c@maz_flow\u201d, the background traffic MAZ-to-MAZ SP assigned flow from highway_maz, if controller.iteration > 0 - modes: must be set on links and match the specified mode codes in the traffic config Network results: - @flow_XX: link PCE flows per class, where XX is the class name in the config - timau: auto travel time - volau: total assigned flow in PCE Notes: - Output matrices are in miles, minutes, and cents (2010 dollars) and are stored/ as real values; - Intrazonal distance/time is one half the distance/time to the nearest neighbor; - Intrazonal bridge and value tolls are assumed to be zero","title":"highway_assign"},{"location":"api/#tm2py.components.network.highway.highway_assign.AssignmentClass","text":"Highway assignment class, represents data from config and conversion to Emme specs Source code in tm2py/components/network/highway/highway_assign.py class AssignmentClass : \"\"\"Highway assignment class, represents data from config and conversion to Emme specs\"\"\" def __init__ ( self , class_config , time_period , iteration ): self . class_config = class_config self . time_period = time_period self . iteration = iteration self . name = class_config [ \"name\" ] . lower () self . skims = class_config . get ( \"skims\" , []) @property def emme_highway_class_spec ( self ) -> EmmeHighwayClassSpec : \"\"\"Construct and return Emme traffic assignment class specification Converted from input config (highway.classes), see Emme Help for SOLA traffic assignment for specification details. Adds time_period as part of demand and skim matrix names. Returns: A nested dictionary corresponding to the expected Emme traffic class specification used in the SOLA assignment. \"\"\" if self . iteration == 0 : demand_matrix = 'ms\"zero\"' else : demand_matrix = f 'mf\" { self . time_period } _ { self . name } \"' class_spec = { \"mode\" : self . class_config . mode_code , \"demand\" : demand_matrix , \"generalized_cost\" : { \"link_costs\" : f \"@cost_ { self . name . lower () } \" , # cost in $0.01 # $/hr -> min/$0.01 \"perception_factor\" : 0.6 / self . class_config . value_of_time , }, \"results\" : { \"link_volumes\" : f \"@flow_ { self . name . lower () } \" , \"od_travel_times\" : { \"shortest_paths\" : f \"mf { self . time_period } _ { self . name } _time\" }, }, \"path_analyses\" : self . emme_class_analysis , } return class_spec @property def emme_class_analysis ( self ) -> List [ EmmeHighwayAnalysisSpec ]: \"\"\"Construct and return a list of path analyses specs which generate the required skims. Returns: A list of nested dictionaries corresponding to the Emme path analysis (per-class) specification used in the SOLA assignment. \"\"\" class_analysis = [] if \"time\" in self . skims : class_analysis . append ( self . emme_analysis_spec ( f \"@cost_ { self . name } \" . lower (), f \"mf { self . time_period } _ { self . name } _cost\" , ) ) for skim_type in self . skims : if skim_type == \"time\" : continue if \"_\" in skim_type : skim_type , group = skim_type . split ( \"_\" ) else : group = \"\" matrix_name = f \"mf { self . time_period } _ { self . name } _ { skim_type }{ group } \" class_analysis . append ( self . emme_analysis_spec ( self . skim_analysis_link_attribute ( skim_type , group ), matrix_name , ) ) return class_analysis @property def skim_matrices ( self ) -> List [ str ]: \"\"\"Returns: List of skim matrix names for this class.\"\"\" skim_matrices = [] if \"time\" in self . skims : skim_matrices . extend ( [ f \" { self . time_period } _ { self . name } _time\" , f \" { self . time_period } _ { self . name } _cost\" , ] ) for skim_type in self . skims : if skim_type == \"time\" : continue if \"_\" in skim_type : skim_type , group = skim_type . split ( \"_\" ) else : group = \"\" skim_matrices . append ( f \" { self . time_period } _ { self . name } _ { skim_type }{ group } \" ) return skim_matrices @staticmethod def emme_analysis_spec ( link_attr : str , matrix_name : str ) -> EmmeHighwayAnalysisSpec : \"\"\"Returns Emme highway class path analysis spec. See Emme Help for SOLA assignment for full specification details. Args: link_attr: input link attribute for which to sum values along the paths matrix_name: full matrix name to store the result of the path analysis Returns: The nested dictionary specification which will generate the skim of link attribute values. \"\"\" analysis_spec = { \"link_component\" : link_attr , \"turn_component\" : None , \"operator\" : \"+\" , \"selection_threshold\" : { \"lower\" : None , \"upper\" : None }, \"path_to_od_composition\" : { \"considered_paths\" : \"ALL\" , \"multiply_path_proportions_by\" : { \"analyzed_demand\" : False , \"path_value\" : True , }, }, \"results\" : { \"od_values\" : matrix_name , \"selected_link_volumes\" : None , \"selected_turn_volumes\" : None , }, } return analysis_spec @staticmethod def skim_analysis_link_attribute ( skim : str , group : str ) -> str : \"\"\"Return the link attribute name for the specified skim type and group. Args: skim: name of skim requested, one of dist, hovdist, tolldist, freeflowtime, bridgetoll, or valuetoll group: subgroup name for the bridgetoll or valuetoll, corresponds to one of the names from config.highway.tolls.dst_vehicle_group_names Returns: A string of the link attribute name used in the analysis. \"\"\" lookup = { \"dist\" : \"length\" , # NOTE: length must be in miles \"hovdist\" : \"@hov_length\" , \"tolldist\" : \"@toll_length\" , \"freeflowtime\" : \"@free_flow_time\" , \"bridgetoll\" : f \"@bridgetoll_ { group } \" , \"valuetoll\" : f \"@valuetoll_ { group } \" , } return lookup [ skim ] emme_class_analysis : List [ EmmeHighwayAnalysisSpec ] property readonly \u00b6 Construct and return a list of path analyses specs which generate the required skims. Returns: Type Description List[EmmeHighwayAnalysisSpec] A list of nested dictionaries corresponding to the Emme path analysis (per-class) specification used in the SOLA assignment. emme_highway_class_spec : EmmeHighwayClassSpec property readonly \u00b6 Construct and return Emme traffic assignment class specification Converted from input config (highway.classes), see Emme Help for SOLA traffic assignment for specification details. Adds time_period as part of demand and skim matrix names. Returns: Type Description EmmeHighwayClassSpec A nested dictionary corresponding to the expected Emme traffic class specification used in the SOLA assignment. skim_matrices : List [ str ] property readonly \u00b6 emme_analysis_spec ( link_attr , matrix_name ) staticmethod \u00b6 Returns Emme highway class path analysis spec. See Emme Help for SOLA assignment for full specification details. Parameters: Name Type Description Default link_attr str input link attribute for which to sum values along the paths required matrix_name str full matrix name to store the result of the path analysis required Returns: Type Description EmmeHighwayAnalysisSpec The nested dictionary specification which will generate the skim of link attribute values. Source code in tm2py/components/network/highway/highway_assign.py @staticmethod def emme_analysis_spec ( link_attr : str , matrix_name : str ) -> EmmeHighwayAnalysisSpec : \"\"\"Returns Emme highway class path analysis spec. See Emme Help for SOLA assignment for full specification details. Args: link_attr: input link attribute for which to sum values along the paths matrix_name: full matrix name to store the result of the path analysis Returns: The nested dictionary specification which will generate the skim of link attribute values. \"\"\" analysis_spec = { \"link_component\" : link_attr , \"turn_component\" : None , \"operator\" : \"+\" , \"selection_threshold\" : { \"lower\" : None , \"upper\" : None }, \"path_to_od_composition\" : { \"considered_paths\" : \"ALL\" , \"multiply_path_proportions_by\" : { \"analyzed_demand\" : False , \"path_value\" : True , }, }, \"results\" : { \"od_values\" : matrix_name , \"selected_link_volumes\" : None , \"selected_turn_volumes\" : None , }, } return analysis_spec skim_analysis_link_attribute ( skim , group ) staticmethod \u00b6 Return the link attribute name for the specified skim type and group. Parameters: Name Type Description Default skim str name of skim requested, one of dist, hovdist, tolldist, freeflowtime, bridgetoll, or valuetoll required group str subgroup name for the bridgetoll or valuetoll, corresponds to one of the names from config.highway.tolls.dst_vehicle_group_names required Returns: Type Description str A string of the link attribute name used in the analysis. Source code in tm2py/components/network/highway/highway_assign.py @staticmethod def skim_analysis_link_attribute ( skim : str , group : str ) -> str : \"\"\"Return the link attribute name for the specified skim type and group. Args: skim: name of skim requested, one of dist, hovdist, tolldist, freeflowtime, bridgetoll, or valuetoll group: subgroup name for the bridgetoll or valuetoll, corresponds to one of the names from config.highway.tolls.dst_vehicle_group_names Returns: A string of the link attribute name used in the analysis. \"\"\" lookup = { \"dist\" : \"length\" , # NOTE: length must be in miles \"hovdist\" : \"@hov_length\" , \"tolldist\" : \"@toll_length\" , \"freeflowtime\" : \"@free_flow_time\" , \"bridgetoll\" : f \"@bridgetoll_ { group } \" , \"valuetoll\" : f \"@valuetoll_ { group } \" , } return lookup [ skim ]","title":"AssignmentClass"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment","text":"Highway assignment and skims. Parameters: Name Type Description Default controller RunController parent RunController object required Source code in tm2py/components/network/highway/highway_assign.py class HighwayAssignment ( Component ): \"\"\"Highway assignment and skims. Args: controller: parent RunController object \"\"\" def __init__ ( self , controller : RunController ): super () . __init__ ( controller ) self . _num_processors = tools . parse_num_processors ( self . config . emme . num_processors ) self . _matrix_cache = None self . _skim_matrices = [] @LogStartEnd ( \"Highway assignment and skims\" , level = \"STATUS\" ) def run ( self ): \"\"\"Run highway assignment\"\"\" demand = PrepareHighwayDemand ( self . controller ) demand . run () for time in self . time_period_names (): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) with self . _setup ( scenario , time ): iteration = self . controller . iteration assign_classes = [ AssignmentClass ( c , time , iteration ) for c in self . config . highway . classes ] if iteration > 0 : self . _copy_maz_flow ( scenario ) else : self . _reset_background_traffic ( scenario ) self . _create_skim_matrices ( scenario , assign_classes ) assign_spec = self . _get_assignment_spec ( assign_classes ) # self.logger.log_dict(assign_spec, level=\"DEBUG\") with self . logger . log_start_end ( \"Run SOLA assignment with path analyses\" , level = \"INFO\" ): assign = self . controller . emme_manager . tool ( \"inro.emme.traffic_assignment.sola_traffic_assignment\" ) assign ( assign_spec , scenario , chart_log_interval = 1 ) # Subtract non-time costs from gen cost to get the raw travel time for emme_class_spec in assign_spec [ \"classes\" ]: self . _calc_time_skim ( emme_class_spec ) # Set intra-zonal for time and dist to be 1/2 nearest neighbour for class_config in self . config . highway . classes : self . _set_intrazonal_values ( time , class_config [ \"name\" ], class_config [ \"skims\" ], ) self . _export_skims ( scenario , time ) @_context def _setup ( self , scenario : EmmeScenario , time_period : str ): \"\"\"Setup and teardown for Emme Matrix cache and list of skim matrices Args: scenario: Emme scenario object time_period: time period name \"\"\" self . _matrix_cache = MatrixCache ( scenario ) self . _skim_matrices = [] msg = f \"Highway assignment for period { time_period } \" with self . logger . log_start_end ( msg , level = \"STATUS\" ): try : yield finally : self . _matrix_cache . clear () self . _matrix_cache = None self . _skim_matrices = [] def _copy_maz_flow ( self , scenario : EmmeScenario ): \"\"\"Copy maz_flow from MAZ demand assignment to ul1 for background traffic. Args: scenario: Emme scenario object\"\"\" self . logger . log_time ( \"Copy @maz_flow to ul1 for background traffic\" , indent = True , level = \"DETAIL\" ) net_calc = NetworkCalculator ( scenario ) net_calc ( \"ul1\" , \"@maz_flow\" ) def _reset_background_traffic ( self , scenario : EmmeScenario ): \"\"\"Set ul1 for background traffic to 0 (no maz-maz flow) Args: scenario: Emme scenario object\"\"\" self . logger . log_time ( \"Set ul1 to 0 for background traffic\" , indent = True , level = \"DETAIL\" ) net_calc = NetworkCalculator ( scenario ) net_calc ( \"ul1\" , \"0\" ) def _create_skim_matrices ( self , scenario : EmmeScenario , assign_classes : List [ AssignmentClass ] ): \"\"\"Create matrices to store skim results in Emme database. Also add the matrices to list of self._skim_matrices. Args: scenario: Emme scenario object assign_classes: list of AssignmentClass objects \"\"\" create_matrix = self . controller . emme_manager . tool ( \"inro.emme.data.matrix.create_matrix\" ) with self . logger . log_start_end ( \"Creating skim matrices\" , level = \"DETAIL\" ): for klass in assign_classes : for matrix_name in klass . skim_matrices : matrix = scenario . emmebank . matrix ( f 'mf\" { matrix_name } \"' ) if not matrix : matrix = create_matrix ( \"mf\" , matrix_name , scenario = scenario , overwrite = True ) self . logger . log ( f \"Create matrix name: { matrix_name } , id: { matrix . id } \" , level = \"DEBUG\" , ) self . _skim_matrices . append ( matrix ) def _get_assignment_spec ( self , assign_classes : List [ AssignmentClass ] ) -> EmmeTrafficAssignmentSpec : \"\"\"Generate template Emme SOLA assignment specification Args: assign_classes: list of AssignmentClass objects Returns Emme specification for SOLA traffic assignment \"\"\" relative_gap = self . config . highway . relative_gap max_iterations = self . config . highway . max_iterations # NOTE: mazmazvol as background traffic in link.data1 (\"ul1\") base_spec = { \"type\" : \"SOLA_TRAFFIC_ASSIGNMENT\" , \"background_traffic\" : { \"link_component\" : \"ul1\" , \"turn_component\" : None , \"add_transit_vehicles\" : False , }, \"classes\" : [ klass . emme_highway_class_spec for klass in assign_classes ], \"stopping_criteria\" : { \"max_iterations\" : max_iterations , \"best_relative_gap\" : 0.0 , \"relative_gap\" : relative_gap , \"normalized_gap\" : 0.0 , }, \"performance_settings\" : { \"number_of_processors\" : self . _num_processors }, } return base_spec def _calc_time_skim ( self , emme_class_spec : EmmeHighwayClassSpec ): \"\"\"Calculate the real time skim =gen_cost-per_fac*link_costs. Args: emme_class_spec: dictionary of the per-class spec sub-section from the Emme SOLA assignment spec, classes list \"\"\" od_travel_times = emme_class_spec [ \"results\" ][ \"od_travel_times\" ][ \"shortest_paths\" ] if od_travel_times is not None : # Total link costs is always the first analysis cost = emme_class_spec [ \"path_analyses\" ][ 0 ][ \"results\" ][ \"od_values\" ] factor = emme_class_spec [ \"generalized_cost\" ][ \"perception_factor\" ] gencost_data = self . _matrix_cache . get_data ( od_travel_times ) cost_data = self . _matrix_cache . get_data ( cost ) time_data = gencost_data - ( factor * cost_data ) self . _matrix_cache . set_data ( od_travel_times , time_data ) def _set_intrazonal_values ( self , time_period : str , class_name : str , skims : List [ str ] ): \"\"\"Set the intrazonal values to 1/2 nearest neighbour for time and distance skims. Args: time_period: time period name (from config) class_name: highway class name (from config) skims: list of requested skims (from config) \"\"\" for skim_name in skims : matrix_name = f \"mf { time_period } _ { class_name } _ { skim_name } \" if skim_name in [ \"time\" , \"distance\" , \"freeflowtime\" , \"hovdist\" , \"tolldist\" ]: data = self . _matrix_cache . get_data ( matrix_name ) # NOTE: sets values for external zones as well np . fill_diagonal ( data , np . inf ) data [ np . diag_indices_from ( data )] = 0.5 * np . nanmin ( data , 1 ) self . _matrix_cache . set_data ( matrix_name , data ) def _export_skims ( self , scenario : EmmeScenario , time_period : str ): \"\"\"Export skims to OMX files by period. Args: scenario: Emme scenario object time_period: time period name \"\"\" # NOTE: skims in separate file by period omx_file_path = self . get_abs_path ( self . config . highway . output_skim_path . format ( period = time_period ) ) os . makedirs ( os . path . dirname ( omx_file_path ), exist_ok = True ) with OMXManager ( omx_file_path , \"w\" , scenario , matrix_cache = self . _matrix_cache ) as omx_file : omx_file . write_matrices ( self . _skim_matrices ) run ( self ) \u00b6 Run highway assignment Source code in tm2py/components/network/highway/highway_assign.py @LogStartEnd ( \"Highway assignment and skims\" , level = \"STATUS\" ) def run ( self ): \"\"\"Run highway assignment\"\"\" demand = PrepareHighwayDemand ( self . controller ) demand . run () for time in self . time_period_names (): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) with self . _setup ( scenario , time ): iteration = self . controller . iteration assign_classes = [ AssignmentClass ( c , time , iteration ) for c in self . config . highway . classes ] if iteration > 0 : self . _copy_maz_flow ( scenario ) else : self . _reset_background_traffic ( scenario ) self . _create_skim_matrices ( scenario , assign_classes ) assign_spec = self . _get_assignment_spec ( assign_classes ) # self.logger.log_dict(assign_spec, level=\"DEBUG\") with self . logger . log_start_end ( \"Run SOLA assignment with path analyses\" , level = \"INFO\" ): assign = self . controller . emme_manager . tool ( \"inro.emme.traffic_assignment.sola_traffic_assignment\" ) assign ( assign_spec , scenario , chart_log_interval = 1 ) # Subtract non-time costs from gen cost to get the raw travel time for emme_class_spec in assign_spec [ \"classes\" ]: self . _calc_time_skim ( emme_class_spec ) # Set intra-zonal for time and dist to be 1/2 nearest neighbour for class_config in self . config . highway . classes : self . _set_intrazonal_values ( time , class_config [ \"name\" ], class_config [ \"skims\" ], ) self . _export_skims ( scenario , time )","title":"HighwayAssignment"},{"location":"api/#tm2py.components.network.highway.highway_maz","text":"Assigns and skims MAZ-to-MAZ demand along shortest generalized cost path. MAZ to MAZ demand is read in from separate OMX matrices as defined under the config table highway.maz_to_maz.demand_county_groups, The demand is expected to be short distance (e.g. <0.5 miles), or within the same TAZ. The demand is grouped into bins of origin -> all destinations, by distance (straight-line) to furthest destination. This limits the size of the shortest path calculated to the minimum required. The bin edges have been predefined after testing as (in miles): [0.0, 0.9, 1.2, 1.8, 2.5, 5.0, 10.0, max_dist] Input: Emme network with: Link attributes: - time attribute, either timau (resulting VDF congested time) or @free_flow_time Node attributes: @maz_id, x, y, and #node_county Demand matrices under highway.maz_to_maz.demand_file, and can have a placeholder auto_{period} MAZ_AUTO {number}_{period}.omx Output: The resulting MAZ-MAZ flows are saved in link @maz_flow which is used as background traffic in the equilibrium Highway assignment.","title":"highway_maz"},{"location":"api/#tm2py.components.network.highway.highway_maz.AssignMAZSPDemand","text":"MAZ-to-MAZ shortest-path highway assignment. Calculates shortest path between MAZs with demand in the Emme network and assigns flow. Source code in tm2py/components/network/highway/highway_maz.py class AssignMAZSPDemand ( Component ): \"\"\"MAZ-to-MAZ shortest-path highway assignment. Calculates shortest path between MAZs with demand in the Emme network and assigns flow. \"\"\" # skip Too many instance attributes recommendation, it is OK as is # pylint: disable=R0902 def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path highway assignment. Args: controller: parent Controller object \"\"\" super () . __init__ ( controller ) self . _scenario = None # bins: performance parameter: crow-fly distance bins # to limit shortest path calculation by origin to furthest destination # semi-exposed for performance testing self . _bin_edges = _default_bin_edges self . _debug = False # Internal attributes to track data through the sequence of steps self . _eb_dir = None self . _mazs = None self . _demand = None self . _max_dist = 0 self . _network = None self . _root_index = None self . _leaf_index = None @LogStartEnd () def run ( self ): \"\"\"Run MAZ-to-MAZ shortest path assignment.\"\"\" emme_manager = self . controller . emme_manager emmebank = emme_manager . emmebank ( self . get_abs_path ( self . config . emme . highway_database_path ) ) self . _eb_dir = os . path . dirname ( emmebank . path ) county_groups = {} for group in self . config . highway . maz_to_maz . demand_county_groups : county_groups [ group . number ] = group . counties for time in self . time_period_names (): with self . logger . log_start_end ( f \"period { time } \" ): self . _scenario = self . get_emme_scenario ( emmebank . path , time ) with self . _setup ( time ): self . _prepare_network () for i , names in county_groups . items (): maz_ids = self . _get_county_mazs ( names ) if len ( maz_ids ) == 0 : self . logger . log ( f \"warning: no mazs for counties { ', ' . join ( names ) } \" ) continue self . _process_demand ( time , i , maz_ids ) demand_bins = self . _group_demand () for i , demand_group in enumerate ( demand_bins ): self . _find_roots_and_leaves ( demand_group [ \"demand\" ]) self . _set_link_cost_maz () self . _run_shortest_path ( time , i , demand_group [ \"dist\" ]) self . _assign_flow ( time , i , demand_group [ \"demand\" ]) @_context def _setup ( self , time : str ): \"\"\"Context setup / teardown, initializes internal attributes. Args: time: name of the time period \"\"\" self . _mazs = None self . _demand = _defaultdict ( lambda : []) self . _max_dist = 0 self . _network = None self . _root_index = None self . _leaf_index = None attributes = [ ( \"LINK\" , \"@link_cost\" , \"total cost MAZ-MAZ\" ), ( \"LINK\" , \"@link_cost_maz\" , \"cost MAZ-MAZ, unused MAZs blocked\" ), ( \"NODE\" , \"@maz_root\" , \"Flag for MAZs which are roots\" ), ( \"NODE\" , \"@maz_leaf\" , \"Flag for MAZs which are leaves\" ), ] with self . controller . emme_manager . temp_attributes_and_restore ( self . _scenario , attributes ): try : yield finally : if not self . _debug : self . _mazs = None self . _demand = None self . _network = None self . _root_index = None self . _leaf_index = None # delete sp path files for bin_no in range ( len ( self . _bin_edges )): file_path = os . path . join ( self . _eb_dir , f \"sp_ { time } _ { bin_no } .ebp\" ) if os . path . exists ( file_path ): os . remove ( file_path ) def _prepare_network ( self ): \"\"\"Calculate link cost (travel time + bridge tolls + operating cost) and load network. Reads Emme network from disk for later node lookups. Optimized to only load attribute values of interest, additional attributes must be added in order to be read from disk. \"\"\" if self . _scenario . has_traffic_results : time_attr = \"(@free_flow_time.max.timau)\" else : time_attr = \"@free_flow_time\" self . logger . log ( f \"Calculating link costs using time { time_attr } \" , level = \"DEBUG\" ) vot = self . config . highway . maz_to_maz . value_of_time op_cost = self . config . highway . maz_to_maz . operating_cost_per_mile net_calc = NetworkCalculator ( self . _scenario ) net_calc ( \"@link_cost\" , f \" { time_attr } + 0.6 / { vot } * (length * { op_cost } )\" ) self . _network = self . controller . emme_manager . get_network ( self . _scenario , { \"NODE\" : [ \"@maz_id\" , \"x\" , \"y\" , \"#node_county\" ], \"LINK\" : []} ) self . _network . create_attribute ( \"LINK\" , \"temp_flow\" ) def _get_county_mazs ( self , counties : List [ str ]) -> List [ EmmeNode ]: \"\"\"Get all MAZ nodes which are located in one of these counties. Used the node attribute #node_county to identify the node location. Name must be an exact match. Catches a mapping of the county names to nodes so nodes are processed only once. Args: counties: list of county names Returns: List of MAZ nodes (Emme Node) which are in these counties. \"\"\" network = self . _network # NOTE: every maz must have a valid #node_county if self . _mazs is None : self . _mazs = _defaultdict ( lambda : []) for node in network . nodes (): if node [ \"@maz_id\" ]: self . _mazs [ node [ \"#node_county\" ]] . append ( node ) mazs = [] for county in counties : mazs . extend ( self . _mazs [ county ]) return sorted ( mazs , key = lambda n : n [ \"@maz_id\" ]) def _process_demand ( self , time : str , index : int , maz_ids : List [ EmmeNode ]): \"\"\"Loads the demand from file and groups by origin node. Sets the demand to self._demand for later processing, grouping the demand in a dictionary by origin node (Emme Node object) to list of dictionaries {\"orig\": orig_node, \"dest\": dest_node, \"dem\": demand, \"dist\": dist} Args: time: time period name index: group index of the demand file, used to find the file by name maz_ids: indexed list of MAZ ID nodes for the county group (active counties for this demand file) \"\"\" data = self . _read_demand_array ( time , index ) origins , destinations = data . nonzero () for orig , dest in zip ( origins , destinations ): # skip intra-maz demand if orig == dest : continue orig_node = maz_ids [ orig ] dest_node = maz_ids [ dest ] dist = _sqrt ( ( dest_node . x - orig_node . x ) ** 2 + ( dest_node . y - orig_node . y ) ** 2 ) if dist > self . _max_dist : self . _max_dist = dist self . _demand [ orig_node ] . append ( { \"orig\" : orig_node , \"dest\" : dest_node , \"dem\" : data [ orig ][ dest ], \"dist\" : dist , } ) def _read_demand_array ( self , time : str , index : int ) -> NumpyArray : \"\"\"Load the demand from file with the specified time and index name. Args: time: time period name index: group index of the demand file, used to find the file by name \"\"\" file_path_tmplt = self . get_abs_path ( self . config . highway . maz_to_maz . demand_file ) omx_file_path = self . get_abs_path ( file_path_tmplt . format ( period = time , number = index ) ) with OMXManager ( omx_file_path , \"r\" ) as omx_file : demand_array = omx_file . read ( \"M0\" ) return demand_array def _group_demand ( self , ) -> List [ Dict [ str , Union [ float , List [ Dict [ str , Union [ float , EmmeNode ]]]]]]: \"\"\"Process the demand loaded from files and create groups based on the origin to the furthest destination with demand. Returns: List of dictionaries, containing the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" # group demand from same origin into distance bins by furthest # distance destination to limit shortest path search radius bin_edges = self . _bin_edges [:] if bin_edges [ - 1 ] < self . _max_dist / 5280.0 : bin_edges . append ( self . _max_dist / 5280.0 ) demand_groups = [ { \"dist\" : edge , \"demand\" : []} for i , edge in enumerate ( bin_edges [ 1 :]) ] for data in self . _demand . values (): max_dist = max ( entry [ \"dist\" ] for entry in data ) / 5280.0 for group in demand_groups : if max_dist < group [ \"dist\" ]: group [ \"demand\" ] . extend ( data ) break for group in demand_groups : self . logger . log_time ( f \"bin dist { group [ 'dist' ] } , size { len ( group [ 'demand' ]) } \" , level = \"DEBUG\" ) # Filter out groups without any demand demand_groups = [ group for group in demand_groups if group [ \"demand\" ]] return demand_groups def _find_roots_and_leaves ( self , demand : List [ Dict [ str , Union [ float , EmmeNode ]]]): \"\"\"Label available MAZ root nodes and leaf nodes for the path calculation. The MAZ nodes which are found as origins in the demand are \"activated\" by setting @maz_root to non-zero, and similarly the leaves have @maz_leaf set to non-zero. Args: demand: list of dictionaries, containing the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" network = self . _network attrs_to_init = [( \"NODE\" , [ \"@maz_root\" , \"@maz_leaf\" ]), ( \"LINK\" , [ \"maz_cost\" ])] for domain , attrs in attrs_to_init : for name in attrs : if name in network . attributes ( domain ): network . delete_attribute ( domain , name ) network . create_attribute ( domain , name ) root_maz_ids = {} leaf_maz_ids = {} for data in demand : o_node , d_node = data [ \"orig\" ], data [ \"dest\" ] root_maz_ids [ o_node . number ] = o_node [ \"@maz_root\" ] = o_node [ \"@maz_id\" ] leaf_maz_ids [ d_node . number ] = d_node [ \"@maz_leaf\" ] = d_node [ \"@maz_id\" ] self . _root_index = { p : i for i , p in enumerate ( sorted ( root_maz_ids . keys ()))} self . _leaf_index = { q : i for i , q in enumerate ( sorted ( leaf_maz_ids . keys ()))} self . controller . emme_manager . copy_attr_values ( \"NODE\" , self . _network , self . _scenario , [ \"@maz_root\" , \"@maz_leaf\" ] ) def _set_link_cost_maz ( self ): \"\"\"Set link cost used in the shortest path forbidden using unavailable connectors. Copy the pre-calculated cost @link_cost to @link_cost_maz, setting value to 1e20 on connectors to unused zone leaves / from unused roots. \"\"\" # forbid egress from MAZ nodes which are not demand roots / # access to MAZ nodes which are not demand leafs net_calc = NetworkCalculator ( self . _scenario ) net_calc . add_calc ( \"@link_cost_maz\" , \"@link_cost\" ) net_calc . add_calc ( \"@link_cost_maz\" , \"1e20\" , \"@maz_root=0 and !@maz_id=0\" ) net_calc . add_calc ( \"@link_cost_maz\" , \"1e20\" , \"@maz_leafj=0 and !@maz_idj=0\" ) net_calc . run () def _run_shortest_path ( self , time : str , bin_no : int , max_radius : float ): \"\"\"Run the shortest path tool to generate paths between the marked nodes. Args: time: time period name bin_no: bin number (id) for this demand segment max_radius: max unit coordinate distance to limit search tree \"\"\" shortest_paths_tool = self . controller . emme_manager . tool ( \"inro.emme.network_calculation.shortest_path\" ) max_radius = max_radius * 5280 + 100 # add some buffer for rounding error ext = \"ebp\" if _USE_BINARY else \"txt\" file_name = f \"sp_ { time } _ { bin_no } . { ext } \" num_processors = parse_num_processors ( self . config . emme . num_processors ) spec = { \"type\" : \"SHORTEST_PATH\" , \"modes\" : [ self . config . highway . maz_to_maz . mode_code ], \"root_nodes\" : \"@maz_root\" , \"leaf_nodes\" : \"@maz_leaf\" , \"link_cost\" : \"@link_cost_maz\" , \"path_constraints\" : { \"max_radius\" : max_radius , \"uturn_allowed\" : False , \"through_leaves\" : False , \"through_centroids\" : False , \"exclude_forbidden_turns\" : False , }, \"results\" : { \"skim_output\" : { \"file\" : \"\" , \"format\" : \"TEXT\" , \"return_numpy\" : False , \"analyses\" : [], }, \"path_output\" : { \"format\" : \"BINARY\" if _USE_BINARY else \"TEXT\" , \"file\" : os . path . join ( self . _eb_dir , file_name ), }, }, \"performance_settings\" : { \"number_of_processors\" : num_processors , \"direction\" : \"FORWARD\" , \"method\" : \"STANDARD\" , }, } shortest_paths_tool ( spec , self . _scenario ) def _assign_flow ( self , time : str , bin_no : int , demand : List [ Dict [ str , Union [ float , EmmeNode ]]] ): \"\"\"Assign the demand along the paths generated from the shortest path tool. Args: time: time period name bin_no: bin number (id) for this demand segment demand: list of dictionaries, containing the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" if _USE_BINARY : self . _assign_flow_binary ( time , bin_no , demand ) else : self . _assign_flow_text ( time , bin_no , demand ) def _assign_flow_text ( self , time : str , bin_no : int , demand : List [ Dict [ str , Union [ float , EmmeNode ]]] ): \"\"\"Assign the demand along the paths generated from the shortest path tool. The paths are read from a text format file, see Emme help for details. Demand is summed in self._network (in memory) using temp_flow attribute and written to scenario (Emmebank / disk) @maz_flow. Args: time: time period name bin_no: bin number (id) for this demand segment demand: list of dictionaries, containin the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" paths = self . _load_text_format_paths ( time , bin_no ) not_assigned , assigned = 0 , 0 for data in demand : orig , dest , dem = data [ \"orig\" ] . number , data [ \"dest\" ] . number , data [ \"dem\" ] path = paths . get ( orig , {}) . get ( dest ) if path is None : not_assigned += dem continue i_node = orig for j_node in path : link = self . _network . link ( i_node , j_node ) link [ \"temp_flow\" ] += dem i_node = j_node assigned += dem self . logger . log_time ( f \"ASSIGN bin { bin_no } : total: { len ( demand ) } \" , level = \"DEBUG\" ) self . logger . log_time ( f \"assigned: { assigned } , not assigned: { not_assigned } \" , level = \"DEBUG\" ) def _load_text_format_paths ( self , time : str , bin_no : int ) -> Dict [ int , Dict [ int , List [ int ]]]: \"\"\"Load all paths from text file and return as nested dictionary. Args: time: time period name bin_no: bin number (id) for this demand segment Returns: All paths as a nested dictionary, path = paths[origin][destination], using the node IDs as integers. \"\"\" paths = _defaultdict ( lambda : {}) with open ( os . path . join ( self . _eb_dir , f \"sp_ { time } _ { bin_no } .txt\" ), \"r\" , encoding = \"utf8\" , ) as paths_file : for line in paths_file : nodes = [ int ( x ) for x in line . split ()] paths [ nodes [ 0 ]][ nodes [ - 1 ]] = nodes [ 1 :] return paths def _assign_flow_binary ( self , time : str , bin_no : int , demand : List [ Dict [ str , Union [ float , EmmeNode ]]] ): \"\"\"Assign the demand along the paths generated from the shortest path tool. The paths are read from a binary format file, see Emme help for details. Demand is summed in self._network (in memory) using temp_flow attribute and written to scenario (Emmebank / disk) @maz_flow. Args: time: time period name bin_no: bin number (id) for this demand segment demand: list of dictionaries, containin the demand in the format {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)} \"\"\" file_name = f \"sp_ { time } _ { bin_no } .ebp\" with open ( os . path . join ( self . _eb_dir , file_name ), \"rb\" ) as paths_file : # read set of path pointers by Orig-Dest sequence from file offset , leaves_nb , path_indicies = self . _get_path_indices ( paths_file ) assigned = 0 not_assigned = 0 bytes_read = offset * 8 # for all orig-dest pairs with demand, load path from file for data in demand : # get file position based on orig-dest index start , end = self . _get_path_location ( data [ \"orig\" ] . number , data [ \"dest\" ] . number , leaves_nb , path_indicies ) # no path found, disconnected zone if start == end : not_assigned += data [ \"dem\" ] continue paths_file . seek ( start * 4 + offset * 8 ) self . _assign_path_flow ( paths_file , start , end , data [ \"dem\" ]) assigned += data [ \"dem\" ] bytes_read += ( end - start ) * 4 self . controller . emme_manager . copy_attr_values ( \"LINK\" , self . _network , self . _scenario , [ \"temp_flow\" ], [ \"@maz_flow\" ] ) self . logger . log_time ( f \"ASSIGN bin { bin_no } , total { len ( demand ) } , assign \" f \" { assigned } , not assign { not_assigned } , bytes { bytes_read } \" , level = \"DEBUG\" , ) @staticmethod def _get_path_indices ( paths_file : BinaryIO ) -> [ int , int , _array . array ]: \"\"\"Get the path header indices. See the Emme Shortest path tool doc for additional details on reading this file. Args: paths_file: binary file access to the generated paths file Returns: 2 ints + array of ints: offset, leafs_nb, path_indicies offset: starting index to read the paths leafs_nb: number of leafs in the shortest path file path_indicies: array of the start index for each root, leaf path in paths_file. \"\"\" # read first 4 integers from file (Q=64-bit unsigned integers) header = _array . array ( \"Q\" ) header . fromfile ( paths_file , 4 ) roots_nb , leaves_nb = header [ 2 : 4 ] # Load sequence of path indices (positions by orig-dest index), # pointing to list of path node IDs in file path_indicies = _array . array ( \"Q\" ) path_indicies . fromfile ( paths_file , roots_nb * leaves_nb + 1 ) offset = roots_nb * leaves_nb + 1 + 4 return offset , leaves_nb , path_indicies def _get_path_location ( self , orig : EmmeNode , dest : EmmeNode , leaves_nb : int , path_indicies : _array . array , ) -> [ int , int ]: \"\"\"Get the location in the paths_file to read. Args: orig: Emme Node object, origin MAZ to query the path dest: Emme Node object, destination MAZ to query the path leaves_nb: number of leaves path_indicies: array of the start index for each root, leaf path in paths_file. Returns: Two integers, start, end start: starting index to read Node ID bytes from paths_file end: ending index to read bytes from paths_file \"\"\" p_index = self . _root_index [ orig ] q_index = self . _leaf_index [ dest ] index = p_index * leaves_nb + q_index start = path_indicies [ index ] end = path_indicies [ index + 1 ] return start , end def _assign_path_flow ( self , paths_file : BinaryIO , start : int , end : int , demand : float ): \"\"\"Add demand to link temp_flow for the path. Args: paths_file: binary file access to read path from start: starting index to read Node ID bytes from paths_file end: ending index to read bytes from paths_file demand: flow demand to add on link \"\"\" # load sequence of Node IDs which define the path (L=32-bit unsigned integers) path = _array . array ( \"L\" ) path . fromfile ( paths_file , end - start ) # proccess path to sequence of links and add flow path_iter = iter ( path ) i_node = next ( path_iter ) for j_node in path_iter : link = self . _network . link ( i_node , j_node ) link [ \"temp_flow\" ] += demand i_node = j_node __init__ ( self , controller ) special \u00b6 MAZ-to-MAZ shortest-path highway assignment. Parameters: Name Type Description Default controller RunController parent Controller object required Source code in tm2py/components/network/highway/highway_maz.py def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path highway assignment. Args: controller: parent Controller object \"\"\" super () . __init__ ( controller ) self . _scenario = None # bins: performance parameter: crow-fly distance bins # to limit shortest path calculation by origin to furthest destination # semi-exposed for performance testing self . _bin_edges = _default_bin_edges self . _debug = False # Internal attributes to track data through the sequence of steps self . _eb_dir = None self . _mazs = None self . _demand = None self . _max_dist = 0 self . _network = None self . _root_index = None self . _leaf_index = None run ( self ) \u00b6 Run MAZ-to-MAZ shortest path assignment. Source code in tm2py/components/network/highway/highway_maz.py @LogStartEnd () def run ( self ): \"\"\"Run MAZ-to-MAZ shortest path assignment.\"\"\" emme_manager = self . controller . emme_manager emmebank = emme_manager . emmebank ( self . get_abs_path ( self . config . emme . highway_database_path ) ) self . _eb_dir = os . path . dirname ( emmebank . path ) county_groups = {} for group in self . config . highway . maz_to_maz . demand_county_groups : county_groups [ group . number ] = group . counties for time in self . time_period_names (): with self . logger . log_start_end ( f \"period { time } \" ): self . _scenario = self . get_emme_scenario ( emmebank . path , time ) with self . _setup ( time ): self . _prepare_network () for i , names in county_groups . items (): maz_ids = self . _get_county_mazs ( names ) if len ( maz_ids ) == 0 : self . logger . log ( f \"warning: no mazs for counties { ', ' . join ( names ) } \" ) continue self . _process_demand ( time , i , maz_ids ) demand_bins = self . _group_demand () for i , demand_group in enumerate ( demand_bins ): self . _find_roots_and_leaves ( demand_group [ \"demand\" ]) self . _set_link_cost_maz () self . _run_shortest_path ( time , i , demand_group [ \"dist\" ]) self . _assign_flow ( time , i , demand_group [ \"demand\" ])","title":"AssignMAZSPDemand"},{"location":"api/#tm2py.components.network.highway.highway_maz.SkimMAZCosts","text":"MAZ-to-MAZ shortest-path skim of time, distance and toll Source code in tm2py/components/network/highway/highway_maz.py class SkimMAZCosts ( Component ): \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll\"\"\" def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll Args: controller: parent RunController object \"\"\" super () . __init__ ( controller ) self . _scenario = None self . _network = None @LogStartEnd () def run ( self ): \"\"\"Run shortest path skims for all available MAZ-to-MAZ O-D pairs. Runs a shortest path builder for each county, using a maz_skim_cost to limit the search. The valid gen cost (time + cost), distance and toll (drive alone) are written to CSV at the output_skim_file path: FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL The following config inputs are used directly in this component. Note also that the network mode_code is prepared in the highway_network component using the excluded_links. config.highway.maz_to_maz: skim_period: name of the period used for the skim, must match one the defined config.time_periods demand_county_groups: used for the list of counties, creates a list out of all listed counties under [].counties output_skim_file: relative path to save the skims value_of_time: value of time used to convert tolls and auto operating cost operating_cost_per_mile: auto operating cost max_skim_cost: max cost value used to limit the shortest path search mode_code: config.emme.num_processors \"\"\" ref_period = None ref_period_name = self . config . highway . maz_to_maz . skim_period for period in self . config . time_periods : if period . name == ref_period_name : ref_period = period break if ref_period is None : raise Exception ( \"highway.maz_to_maz.skim_period: is not the name of an existing time_period\" ) self . _scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , ref_period . name ) # prepare output file and write header output = self . get_abs_path ( self . config . highway . maz_to_maz . output_skim_file ) os . makedirs ( os . path . dirname ( output ), exist_ok = True ) with open ( output , \"w\" , encoding = \"utf8\" ) as output_file : output_file . write ( \"FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL \\n \" ) counties = [] for group in self . config . highway . maz_to_maz . demand_county_groups : counties . extend ( group . counties ) with self . _setup (): self . _prepare_network () for county in counties : num_roots = self . _mark_roots ( county ) if num_roots == 0 : continue sp_values = self . _run_shortest_path () self . _export_results ( sp_values ) @_context def _setup ( self ): \"\"\"Creates the temp attributes used in the component.\"\"\" attributes = [ ( \"LINK\" , \"@link_cost\" , \"total cost MAZ-MAZ\" ), ( \"NODE\" , \"@maz_root\" , \"selected roots (origins)\" ), ] with self . controller . emme_manager . temp_attributes_and_restore ( self . _scenario , attributes ): try : yield finally : self . _network = None # clear network obj ref to free memory @LogStartEnd () def _prepare_network ( self ): \"\"\"Calculates the link cost in @link_cost and loads the network to self._network\"\"\" net_calc = NetworkCalculator ( self . _scenario ) if self . _scenario . has_traffic_results : time_attr = \"(@free_flow_time.max.timau)\" else : time_attr = \"@free_flow_time\" vot = self . config . highway . maz_to_maz . value_of_time op_cost = self . config . highway . maz_to_maz . operating_cost_per_mile net_calc ( \"@link_cost\" , f \" { time_attr } + 0.6 / { vot } * (length * { op_cost } )\" ) self . _network = self . controller . emme_manager . get_network ( self . _scenario , { \"NODE\" : [ \"@maz_id\" , \"#node_county\" ]} ) def _mark_roots ( self , county : str ) -> int : \"\"\"Mark the available roots in the county.\"\"\" count_roots = 0 for node in self . _network . nodes (): if node [ \"@maz_id\" ] > 0 and node [ \"#node_county\" ] == county : node [ \"@maz_root\" ] = node [ \"@maz_id\" ] count_roots += 1 else : node [ \"@maz_root\" ] = 0 values = self . _network . get_attribute_values ( \"NODE\" , [ \"@maz_root\" ]) self . _scenario . set_attribute_values ( \"NODE\" , [ \"@maz_root\" ], values ) return count_roots def _run_shortest_path ( self ) -> Dict [ str , NumpyArray ]: \"\"\"Run shortest paths tool and return dictionary of skim results name, numpy arrays. O-D pairs are limited by a max cost value from config.highway.maz_to_maz.max_skim_cost, from roots marked by @maz_root to all available leaves at @maz_id. Returns: A dictionary with keys \"COST\", \"DISTANCE\", and \"BRIDGETOLL\", and numpy arrays of SP values for available O-D pairs \"\"\" shortest_paths_tool = self . controller . emme_manager . tool ( \"inro.emme.network_calculation.shortest_path\" ) num_processors = parse_num_processors ( self . config . emme . num_processors ) max_cost = float ( self . config . highway . maz_to_maz . max_skim_cost ) spec = { \"type\" : \"SHORTEST_PATH\" , \"modes\" : [ self . config . highway . maz_to_maz . mode_code ], \"root_nodes\" : \"@maz_root\" , \"leaf_nodes\" : \"@maz_id\" , \"link_cost\" : \"@link_cost\" , \"path_constraints\" : { \"max_cost\" : max_cost , \"uturn_allowed\" : False , \"through_leaves\" : False , \"through_centroids\" : False , \"exclude_forbidden_turns\" : False , }, \"results\" : { \"skim_output\" : { \"return_numpy\" : True , \"analyses\" : [ { \"component\" : \"SHORTEST_PATH_COST\" , \"operator\" : \"+\" , \"name\" : \"COST\" , \"description\" : \"\" , }, { \"component\" : \"length\" , \"operator\" : \"+\" , \"name\" : \"DISTANCE\" , \"description\" : \"\" , }, { \"component\" : \"@bridgetoll_da\" , \"operator\" : \"+\" , \"name\" : \"BRIDGETOLL\" , \"description\" : \"\" , }, ], \"format\" : \"OMX\" , } }, \"performance_settings\" : { \"number_of_processors\" : num_processors , \"direction\" : \"FORWARD\" , \"method\" : \"STANDARD\" , }, } sp_values = shortest_paths_tool ( spec , self . _scenario ) return sp_values def _export_results ( self , sp_values : Dict [ str , NumpyArray ]): \"\"\"Write matrix skims to CSV. The matrices are filtered to omit rows for which the COST is < 0 or > 1e19 (Emme uses 1e20 to indicate inaccessible zone pairs). sp_values: dictionary of matrix costs, with the three keys \"COST\", \"DISTANCE\", and \"BRIDGETOLL\" and Numpy arrays of values \"\"\" # get list of MAZ IDS roots = [ node [ \"@maz_root\" ] for node in self . _network . nodes () if node [ \"@maz_root\" ] ] leaves = [ node [ \"@maz_id\" ] for node in self . _network . nodes () if node [ \"@maz_id\" ]] # build dataframe with output data and to/from MAZ ids root_ids = np . repeat ( roots , len ( leaves )) leaf_ids = leaves * len ( roots ) result_df = pd . DataFrame ( { \"FROM_ZONE\" : root_ids , \"TO_ZONE\" : leaf_ids , \"COST\" : sp_values [ \"COST\" ] . flatten (), \"DISTANCE\" : sp_values [ \"DISTANCE\" ] . flatten (), \"BRIDGETOLL\" : sp_values [ \"BRIDGETOLL\" ] . flatten (), } ) # drop 0's / 1e20 result_df = result_df . query ( \"COST > 0 & COST < 1e19\" ) # write remaining values to text file # FROM_ZONE,TO_ZONE,COST,DISTANCE,BRIDGETOLL output = self . get_abs_path ( self . config . highway . maz_to_maz . output_skim_file ) with open ( output , \"a\" , newline = \"\" , encoding = \"utf8\" ) as output_file : result_df . to_csv ( output_file , header = False , index = False ) __init__ ( self , controller ) special \u00b6 MAZ-to-MAZ shortest-path skim of time, distance and toll Parameters: Name Type Description Default controller RunController parent RunController object required Source code in tm2py/components/network/highway/highway_maz.py def __init__ ( self , controller : RunController ): \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll Args: controller: parent RunController object \"\"\" super () . __init__ ( controller ) self . _scenario = None self . _network = None run ( self ) \u00b6 Run shortest path skims for all available MAZ-to-MAZ O-D pairs. Runs a shortest path builder for each county, using a maz_skim_cost to limit the search. The valid gen cost (time + cost), distance and toll (drive alone) are written to CSV at the output_skim_file path: FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL The following config inputs are used directly in this component. Note also that the network mode_code is prepared in the highway_network component using the excluded_links. config.highway.maz_to_maz: !!! skim_period \u201cname of the period used for the skim, must match one the\u201d defined config.time_periods !!! demand_county_groups \u201cused for the list of counties, creates a list out\u201d of all listed counties under [].counties output_skim_file: relative path to save the skims value_of_time: value of time used to convert tolls and auto operating cost operating_cost_per_mile: auto operating cost max_skim_cost: max cost value used to limit the shortest path search mode_code: config.emme.num_processors Source code in tm2py/components/network/highway/highway_maz.py @LogStartEnd () def run ( self ): \"\"\"Run shortest path skims for all available MAZ-to-MAZ O-D pairs. Runs a shortest path builder for each county, using a maz_skim_cost to limit the search. The valid gen cost (time + cost), distance and toll (drive alone) are written to CSV at the output_skim_file path: FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL The following config inputs are used directly in this component. Note also that the network mode_code is prepared in the highway_network component using the excluded_links. config.highway.maz_to_maz: skim_period: name of the period used for the skim, must match one the defined config.time_periods demand_county_groups: used for the list of counties, creates a list out of all listed counties under [].counties output_skim_file: relative path to save the skims value_of_time: value of time used to convert tolls and auto operating cost operating_cost_per_mile: auto operating cost max_skim_cost: max cost value used to limit the shortest path search mode_code: config.emme.num_processors \"\"\" ref_period = None ref_period_name = self . config . highway . maz_to_maz . skim_period for period in self . config . time_periods : if period . name == ref_period_name : ref_period = period break if ref_period is None : raise Exception ( \"highway.maz_to_maz.skim_period: is not the name of an existing time_period\" ) self . _scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , ref_period . name ) # prepare output file and write header output = self . get_abs_path ( self . config . highway . maz_to_maz . output_skim_file ) os . makedirs ( os . path . dirname ( output ), exist_ok = True ) with open ( output , \"w\" , encoding = \"utf8\" ) as output_file : output_file . write ( \"FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL \\n \" ) counties = [] for group in self . config . highway . maz_to_maz . demand_county_groups : counties . extend ( group . counties ) with self . _setup (): self . _prepare_network () for county in counties : num_roots = self . _mark_roots ( county ) if num_roots == 0 : continue sp_values = self . _run_shortest_path () self . _export_results ( sp_values )","title":"SkimMAZCosts"},{"location":"api/#tm2py.components.network.highway.highway_network","text":"Module for highway network preparation steps. Creates required attributes and populates input values needed for highway assignments. The toll values, VDFs, per-class cost (tolls+operating costs), modes and skim link attributes are calculated. The following link attributes are used as input: - \u201c@capclass\u201d: link capclass index - \u201clength\u201d: standard link length, in miles - \u201c@tollbooth\u201d: label to separate bridgetolls from valuetolls - \u201c@tollseg\u201d: toll segment, used to index toll value lookups from the toll file (under config.highway.tolls.file_path) - \u201c@ft\u201d: functional class, used to assign VDFs The following keys and tables are used from the config: highway.tolls.file_path: relative path to input toll file highway.tolls.src_vehicle_group_names: names used in tolls file for toll class values highway.tolls.dst_vehicle_group_names: corresponding names used in network attributes toll classes highway.tolls.tollbooth_start_index: index to split point bridge tolls (< this value) from distance value tolls (>= this value) highway.classes: the list of assignment classes, see the notes under highway_assign for detailed explanation highway.capclass_lookup: the lookup table mapping the link @capclass setting to capacity (@capacity), free_flow_speed (@free_flow_speec) and critical_speed (used to calculate @ja for akcelik type functions) highway.generic_highway_mode_code: unique (with other mode_codes) single character used to label entire auto network in Emme highway.maz_to_maz.mode_code: unique (with other mode_codes) single character used to label MAZ local auto network including connectors The following link attributes are created (overwritten) and are subsequently used in the highway assignments. - \u201c@flow_XX\u201d: link PCE flows per class, where XX is the class name in the config - \u201c@maz_flow\u201d: Assigned MAZ-to-MAZ flow The following attributes are calculated: - vdf: volume delay function to use - \u201c@capacity\u201d: total link capacity - \u201c@ja\u201d: akcelik delay parameter - \u201c@hov_length\u201d: length with HOV lanes - \u201c@toll_length\u201d: length with tolls - \u201c@bridgetoll_YY\u201d: the bridge toll for class subgroup YY - \u201c@valuetoll_YY\u201d: the \u201cvalue\u201d, non-bridge toll for class subgroup YY - \u201c@cost_YY\u201d: total cost for class YY","title":"highway_network"},{"location":"api/#tm2py.components.network.highway.highway_network.PrepareNetwork","text":"Highway network preparation Source code in tm2py/components/network/highway/highway_network.py class PrepareNetwork ( Component ): \"\"\"Highway network preparation\"\"\" @LogStartEnd ( \"prepare network attributes and modes\" ) def run ( self ): \"\"\"Run network preparation step\"\"\" for time in self . time_period_names (): with self . controller . emme_manager . logbook_trace ( f \"prepare for highway assignment { time } \" ): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) self . _create_class_attributes ( scenario , time ) network = scenario . get_network () self . _set_tolls ( network , time ) self . _set_vdf_attributes ( network , time ) self . _set_link_modes ( network ) self . _calc_link_skim_lengths ( network ) self . _calc_link_class_costs ( network ) scenario . publish_network ( network ) def _create_class_attributes ( self , scenario : EmmeScenario , time_period : str ): \"\"\"Create required network attributes including per-class cost and flow attributes.\"\"\" create_attribute = self . controller . emme_manager . tool ( \"inro.emme.data.extra_attribute.create_extra_attribute\" ) attributes = { \"LINK\" : [ ( \"@capacity\" , \"total link capacity\" ), ( \"@ja\" , \"akcelik delay parameter\" ), ( \"@maz_flow\" , \"Assigned MAZ-to-MAZ flow\" ), ( \"@hov_length\" , \"length with HOV lanes\" ), ( \"@toll_length\" , \"length with tolls\" ), ] } # toll field attributes by bridge and value and toll definition dst_veh_groups = self . config . highway . tolls . dst_vehicle_group_names for dst_veh in dst_veh_groups : for toll_type in \"bridge\" , \"value\" : attributes [ \"LINK\" ] . append ( ( f \"@ { toll_type } toll_ { dst_veh } \" , f \" { toll_type } toll value for { dst_veh } \" , ) ) # results for link cost and assigned flow for assign_class in self . config . highway . classes : attributes [ \"LINK\" ] . append ( ( f \"@cost_ { assign_class . name . lower () } \" , f ' { time_period } { assign_class [ \"description\" ] } total costs' [: 40 ], ) ) attributes [ \"LINK\" ] . append ( ( f \"@flow_ { assign_class . name . lower () } \" , f ' { time_period } { assign_class [ \"description\" ] } link volume' [: 40 ], ) ) for domain , attrs in attributes . items (): for name , desc in attrs : create_attribute ( domain , name , desc , overwrite = True , scenario = scenario ) def _set_tolls ( self , network : EmmeNetwork , time_period : str ): \"\"\"Set the tolls in the network from the toll reference file.\"\"\" toll_index = self . _get_toll_indices () src_veh_groups = self . config . highway . tolls . src_vehicle_group_names dst_veh_groups = self . config . highway . tolls . dst_vehicle_group_names tollbooth_start_index = self . config . highway . tolls . tollbooth_start_index for link in network . links (): if link [ \"@tollbooth\" ]: index = ( link [ \"@tollbooth\" ] * 1000 + link [ \"@tollseg\" ] * 10 + link [ \"@useclass\" ] ) data_row = toll_index . get ( index ) if data_row is None : self . logger . log ( f \"set tolls failed index lookup { index } , link { link . id } \" , level = \"TRACE\" , ) continue # tolls will remain at zero # if index is below tollbooth start index then this is a bridge # (point toll), available for all traffic assignment classes if link [ \"@tollbooth\" ] < tollbooth_start_index : for src_veh , dst_veh in zip ( src_veh_groups , dst_veh_groups ): link [ f \"@bridgetoll_ { dst_veh } \" ] = ( data_row [ f \"toll { time_period . lower () } _ { src_veh } \" ] * 100 ) else : # else, this is a tollway with a per-mile charge for src_veh , dst_veh in zip ( src_veh_groups , dst_veh_groups ): link [ f \"@valuetoll_ { dst_veh } \" ] = ( data_row [ f \"toll { time_period . lower () } _ { src_veh } \" ] * link . length * 100 ) def _get_toll_indices ( self ) -> Dict [ int , Dict [ str , str ]]: \"\"\"Get the mapping of toll lookup table from the toll reference file.\"\"\" toll_file_path = self . get_abs_path ( self . config . highway . tolls . file_path ) tolls = {} with open ( toll_file_path , \"r\" , encoding = \"UTF8\" ) as toll_file : header = next ( toll_file ) . split ( \",\" ) for line in toll_file : data = dict ( zip ( header , line . split ( \",\" ))) tolls [ int ( data [ \"fac_index\" ])] = data return tolls def _set_vdf_attributes ( self , network : EmmeNetwork , time_period : str ): \"\"\"Set capacity, VDF and critical speed on links\"\"\" capacity_map = {} critical_speed_map = {} for row in self . config . highway . capclass_lookup : if row . get ( \"capacity\" ) is not None : capacity_map [ row [ \"capclass\" ]] = row . get ( \"capacity\" ) if row . get ( \"critical_speed\" ) is not None : critical_speed_map [ row [ \"capclass\" ]] = row . get ( \"critical_speed\" ) tp_mapping = { tp . name : tp . highway_capacity_factor for tp in self . config . time_periods } period_capacity_factor = tp_mapping [ time_period ] akcelik_vdfs = [ 3 , 4 , 5 , 7 , 8 , 10 , 11 , 12 , 13 , 14 ] for link in network . links (): cap_lanehour = capacity_map [ link [ \"@capclass\" ]] link [ \"@capacity\" ] = cap_lanehour * period_capacity_factor * link [ \"@lanes\" ] link . volume_delay_func = int ( link [ \"@ft\" ]) # re-mapping links with type 99 to type 7 \"local road of minor importance\" if link . volume_delay_func == 99 : link . volume_delay_func = 7 # num_lanes not used directly, but set for reference link . num_lanes = max ( min ( 9.9 , link [ \"@lanes\" ]), 1.0 ) if link . volume_delay_func in akcelik_vdfs and link [ \"@free_flow_speed\" ] > 0 : dist = link . length critical_speed = critical_speed_map [ link [ \"@capclass\" ]] t_c = dist / critical_speed t_o = dist / link [ \"@free_flow_speed\" ] link [ \"@ja\" ] = 16 * ( t_c - t_o ) ** 2 def _set_link_modes ( self , network : EmmeNetwork ): \"\"\"Set the link modes based on the per-class 'excluded_links' set.\"\"\" # first reset link modes (script run more than once) # \"generic_highway_mode_code\" must already be created (in import to Emme script) auto_mode = { network . mode ( self . config . highway . generic_highway_mode_code )} used_modes = { network . mode ( assign_class . mode_code ) for assign_class in self . config . highway . classes } used_modes . add ( network . mode ( self . config . highway . maz_to_maz . mode_code )) for link in network . links (): link . modes -= used_modes if link [ \"@drive_link\" ]: link . modes |= auto_mode for mode in used_modes : if mode is not None : network . delete_mode ( mode ) # Create special access/egress mode for MAZ connectors maz_access_mode = network . create_mode ( \"AUX_AUTO\" , self . config . highway . maz_to_maz . mode_code ) maz_access_mode . description = \"MAZ access\" # create modes from class spec # (duplicate mode codes allowed provided the excluded_links is the same) mode_excluded_links = {} for assign_class in self . config . highway . classes : if assign_class . mode_code in mode_excluded_links : if ( assign_class . excluded_links != mode_excluded_links [ assign_class . mode_code ] ): ex_links1 = mode_excluded_links [ assign_class . mode_code ] ex_links2 = assign_class . excluded_links raise Exception ( f \"config error: highway.classes, duplicated mode codes \" f \"(' { assign_class . mode_code } ') with different excluded \" f \"links: { ex_links1 } and { ex_links2 } \" ) continue mode = network . create_mode ( \"AUX_AUTO\" , assign_class . mode_code ) mode . description = assign_class . name mode_excluded_links [ mode . id ] = assign_class . excluded_links dst_veh_groups = self . config . highway . tolls . dst_vehicle_group_names for link in network . links (): modes = set ( m . id for m in link . modes ) if link . i_node [ \"@maz_id\" ] + link . j_node [ \"@maz_id\" ] > 0 : modes . add ( maz_access_mode . id ) link . modes = modes continue if not link [ \"@drive_link\" ]: continue exclude_links_map = { \"is_sr\" : link [ \"@useclass\" ] in [ 2 , 3 ], \"is_sr2\" : link [ \"@useclass\" ] == 2 , \"is_sr3\" : link [ \"@useclass\" ] == 3 , \"is_auto_only\" : link [ \"@useclass\" ] in [ 2 , 3 , 4 ], } for dst_veh in dst_veh_groups : exclude_links_map [ f \"is_toll_ { dst_veh } \" ] = ( link [ f \"@valuetoll_ { dst_veh } \" ] > 0 ) self . _apply_exclusions ( self . config . highway . maz_to_maz . excluded_links , maz_access_mode . id , modes , exclude_links_map , ) for assign_class in self . config . highway . classes : self . _apply_exclusions ( assign_class . excluded_links , assign_class . mode_code , modes , exclude_links_map , ) link . modes = modes @staticmethod def _apply_exclusions ( excluded_links_criteria : List [ str ], mode_code : str , modes_set : Set [ str ], link_values : Dict [ str , bool ], ): \"\"\"Apply the exclusion criteria to set the link modes.\"\"\" for criteria in excluded_links_criteria : if link_values [ criteria ]: return modes_set . add ( mode_code ) def _calc_link_skim_lengths ( self , network : EmmeNetwork ): \"\"\"Calculate the length attributes used in the highway skims.\"\"\" tollbooth_start_index = self . config . highway . tolls . tollbooth_start_index for link in network . links (): # distance in hov lanes / facilities if 2 <= link [ \"@useclass\" ] <= 3 : link [ \"@hov_length\" ] = link . length else : link [ \"@hov_length\" ] = 0 # distance on non-bridge toll facilities if link [ \"@tollbooth\" ] > tollbooth_start_index : link [ \"@toll_length\" ] = link . length else : link [ \"@toll_length\" ] = 0 def _calc_link_class_costs ( self , network : EmmeNetwork ): \"\"\"Calculate the per-class link cost from the tolls and operating costs.\"\"\" for assign_class in self . config . highway . classes : cost_attr = f \"@cost_ { assign_class . name . lower () } \" op_cost = assign_class [ \"operating_cost_per_mile\" ] toll_factor = assign_class . get ( \"toll_factor\" ) if toll_factor is None : toll_factor = 1.0 for link in network . links (): toll_value = sum ( link [ toll_attr ] for toll_attr in assign_class [ \"toll\" ]) link [ cost_attr ] = link . length * op_cost + toll_value * toll_factor run ( self ) \u00b6 Run network preparation step Source code in tm2py/components/network/highway/highway_network.py @LogStartEnd ( \"prepare network attributes and modes\" ) def run ( self ): \"\"\"Run network preparation step\"\"\" for time in self . time_period_names (): with self . controller . emme_manager . logbook_trace ( f \"prepare for highway assignment { time } \" ): scenario = self . get_emme_scenario ( self . config . emme . highway_database_path , time ) self . _create_class_attributes ( scenario , time ) network = scenario . get_network () self . _set_tolls ( network , time ) self . _set_vdf_attributes ( network , time ) self . _set_link_modes ( network ) self . _calc_link_skim_lengths ( network ) self . _calc_link_class_costs ( network ) scenario . publish_network ( network )","title":"PrepareNetwork"},{"location":"api/#tm2py.components.network.transit","text":"Transit assignment and skim module","title":"transit"},{"location":"api/#tm2py.components.network.transit.transit_assign","text":"Transit assignment module","title":"transit_assign"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignment","text":"Run transit assignment. Source code in tm2py/components/network/transit/transit_assign.py class TransitAssignment ( Component ): \"\"\"Run transit assignment.\"\"\"","title":"TransitAssignment"},{"location":"api/#tm2py.components.network.transit.transit_skim","text":"Transit skims module","title":"transit_skim"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim","text":"Run transit skims Source code in tm2py/components/network/transit/transit_skim.py class TransitSkim ( Component ): \"\"\"Run transit skims\"\"\"","title":"TransitSkim"},{"location":"api/#emme-wrappers","text":"","title":"Emme Wrappers"},{"location":"api/#tm2py.emme","text":"","title":"emme"},{"location":"api/#tm2py.emme.manager","text":"Module for Emme Manager for centralized management of Emme projects Centralized location for Emme API imports, which are automatically replaced by unittest.Mock / MagicMock to support testing where Emme is not installed. Contains EmmeManager class for access to common Emme-related procedures (common-code / utility-type methods) and caching access to Emme project, and Modeller.","title":"manager"},{"location":"api/#tm2py.emme.manager.EmmeManager","text":"Centralized cache for Emme project and related calls for traffic and transit assignments. Wraps Emme Desktop API (see Emme API Reference for additional details on the Emme objects). Source code in tm2py/emme/manager.py class EmmeManager : \"\"\"Centralized cache for Emme project and related calls for traffic and transit assignments. Wraps Emme Desktop API (see Emme API Reference for additional details on the Emme objects). \"\"\" def __init__ ( self ): # mapping of Emme project path to Emme Desktop API object for reference # (projects are opened only once) self . _project_cache = _EMME_PROJECT_REF def close_all ( self ): \"\"\" Close all open cached Emme project(s). Should be called at the end of the model process / Emme assignments. \"\"\" while self . _project_cache : _ , app = self . _project_cache . popitem () app . close () def create_project ( self , project_dir : str , name : str ) -> EmmeDesktopApp : \"\"\"Create, open and return Emme project Args: project_dir: path to Emme root directory for new Emme project name: name for the Emme project Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" emp_path = _app . create_project ( project_dir , name ) return self . project ( emp_path ) def project ( self , project_path : str ) -> EmmeDesktopApp : \"\"\"Return already open Emme project, or open new Desktop session if not found. Args: project_path: valid path to Emme project *.emp file Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" project_path = os . path . normcase ( os . path . realpath ( project_path )) emme_project = self . _project_cache . get ( project_path ) if emme_project : try : # Check if the Emme window was closed emme_project . current_window () except _socket_error : emme_project = None # if window is not opened in this process, start a new one if emme_project is None : if not os . path . isfile ( project_path ): raise Exception ( f \"Emme project path does not exist { project_path } \" ) emme_project = _app . start_dedicated ( visible = True , user_initials = \"inro\" , project = project_path ) self . _project_cache [ project_path ] = emme_project return emme_project @staticmethod def emmebank ( path : str ) -> Emmebank : \"\"\"Open and return the Emmebank at path. Args: path: valid system path pointing to an Emmebank file Returns: Emmebank object, see Emme API Reference, Database section for details. \"\"\" if not path . endswith ( \"emmebank\" ): path = os . path . join ( path , \"emmebank\" ) return Emmebank ( path ) def change_emmebank_dimensions ( self , emmebank : Emmebank , dimensions : Dict [ str , int ] ): \"\"\"Change the Emmebank dimensions as specified. See the Emme API help for details. Args: emmebank: the Emmebank object to change the dimensions dimensions: dictionary of the specified dimensions to set. \"\"\" dims = emmebank . dimensions new_dims = dims . copy () new_dims . update ( dimensions ) if dims != new_dims : change_dimensions = self . tool ( \"inro.emme.data.database.change_database_dimensions\" ) change_dimensions ( new_dims , emmebank , keep_backup = False ) def modeller ( self , emme_project : EmmeDesktopApp = None ) -> EmmeModeller : \"\"\"Initialize and return Modeller object. If Modeller has not already been initialized it will do so on specified Emme project, or the first Emme project opened if not provided. If already initialized Modeller will reference whichever project was used first. Args: emme_project: open 'Emme Desktop' application (inro.emme.desktop.app) Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" # pylint: disable=E0611, E0401, E1101 try : return EmmeModeller () except AssertionError as error : if emme_project is None : if self . _project_cache : emme_project = next ( iter ( self . _project_cache . values ())) else : raise Exception ( \"modeller not yet initialized and no cached Emme project,\" \" emme_project arg must be provided\" ) from error return EmmeModeller ( emme_project ) def tool ( self , namespace : str ): \"\"\"Return the Modeller tool at namespace. Returns: Corresponding Tool object, see Emme Help for full details. \"\"\" return self . modeller () . tool ( namespace ) @staticmethod @_context def temp_attributes_and_restore ( scenario : EmmeScenario , attributes : List [ List [ str ]] ): \"\"\"Create temp extra attribute and network field, and backup values and state and restore. Allows the use of temporary attributes which may conflict with existing attributes. The temp created attributes are deleted at the end, and if there were pre-existing attributes with the same names the values are restored. Note that name conflicts may still arise in the shorthand inheritance systems for the network hierarchy tree (@node attribute reserves -> @nodei, @nodej, etc, see Emme help Network calculations for full list) which will raise an error in the Emme API. Args: scenario: Emme scenario object attributes: list of attribute details, where details is a list of 3 items for extra attributes and 4 for network fields: domain, name, description[, atype] \"\"\" attrs_to_delete = [] fields_to_delete = [] attrs_to_restore = dict ( ( d , []) for d in [ \"NODE\" , \"LINK\" , \"TURN\" , \"TRANSIT_LINE\" , \"TRANSIT_SEGMENT\" ] ) for details in attributes : domain , name , desc = details [: 3 ] attr = scenario . extra_attribute ( name ) field = scenario . network_field ( domain , name ) if attr or field : attrs_to_restore [ domain ] . append ( name ) elif name . startswith ( \"@\" ): attr = scenario . create_extra_attribute ( domain , name ) attr . description = desc attrs_to_delete . append ( name ) else : atype = details [ 3 ] field = scenario . create_nertwork_field ( domain , name , atype ) field . description = desc fields_to_delete . append (( domain , name )) backup = [] for domain , names in attrs_to_restore . items (): if names : backup . append ( ( domain , names , scenario . get_attribute_values ( domain , names )) ) try : yield finally : for name in attrs_to_delete : scenario . delete_extra_attribute ( name ) for domain , name in fields_to_delete : scenario . delete_network_field ( domain , name ) for domain , names , values in backup : scenario . set_attribute_values ( domain , names , values ) @staticmethod def copy_attr_values ( domain : str , src : Union [ EmmeScenario , EmmeNetwork ], dst : Union [ EmmeScenario , EmmeNetwork ], src_names : List [ str ], dst_names : List [ str ] = None , ): \"\"\"Copy attribute values between Emme scenario (on disk) and network (in memory). Args: domain: attribute domain, one of \"NODE\", \"LINK\", \"TURN\", \"TRANSIT_LINE\", \"TRANSIT_SEGMENT\" src: source Emme scenario or network to load values from dst: destination Emme scenario or network to save values to src_names: names of the attributes for loading values dst_names: optional, names of the attributes to save values as, defaults to using the src_names if not specified Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" if dst_names is None : dst_names = src_names values = src . get_attribute_values ( domain , src_names ) dst . set_attribute_values ( domain , dst_names , values ) def get_network ( self , scenario : EmmeScenario , attributes : Dict [ str , List [ str ]] = None ) -> EmmeNetwork : \"\"\"Read partial Emme network from the scenario for the domains and attributes specified. Optimized load of network object from scenario (disk / emmebank) for only the domains specified, and only reads the attributes specified. The attributes is a dictionary with keys for the required domains, and values as lists of the attributes required by domain. Wrapper for scenario.get_partial_network followed by scenario.get_attribute_values and network.set_attribute_values. Args: scenario: Emme scenario object, see Emme API reference attributes: dictionary of domain names to lists of attribute names Returns: Emme Network object, see Emme API Reference, Network section for details. \"\"\" if attributes is None : return scenario . get_network () network = scenario . get_partial_network ( attributes . keys (), include_attributes = False ) for domain , attrs in attributes . items (): if attrs : self . copy_attr_values ( domain , scenario , network , attrs ) return network @staticmethod def logbook_write ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Emme Logbook at the current nesting level. Wrapper for inro.modeller.logbook_write. Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} logbook_write ( name , value = value , attributes = attributes ) @staticmethod @_context def logbook_trace ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Modeller logbook and create a nest in the Logbook. Wrapper for inro.modeller.logbook_trace. Used in the with statement, e.g. ``` with _emme_tools.logbook_trace('My nest'): _emme_tools.logbook_write('This entry is nested') ``` Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry. \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} with logbook_trace ( name , value = value , attributes = attributes ): yield","title":"EmmeManager"},{"location":"api/#tm2py.emme.manager.EmmeManager.change_emmebank_dimensions","text":"Change the Emmebank dimensions as specified. See the Emme API help for details. Parameters: Name Type Description Default emmebank <MagicMock name='mock.Emmebank' id='140339788584896'> the Emmebank object to change the dimensions required dimensions Dict[str, int] dictionary of the specified dimensions to set. required Source code in tm2py/emme/manager.py def change_emmebank_dimensions ( self , emmebank : Emmebank , dimensions : Dict [ str , int ] ): \"\"\"Change the Emmebank dimensions as specified. See the Emme API help for details. Args: emmebank: the Emmebank object to change the dimensions dimensions: dictionary of the specified dimensions to set. \"\"\" dims = emmebank . dimensions new_dims = dims . copy () new_dims . update ( dimensions ) if dims != new_dims : change_dimensions = self . tool ( \"inro.emme.data.database.change_database_dimensions\" ) change_dimensions ( new_dims , emmebank , keep_backup = False )","title":"change_emmebank_dimensions()"},{"location":"api/#tm2py.emme.manager.EmmeManager.close_all","text":"Close all open cached Emme project(s). Should be called at the end of the model process / Emme assignments. Source code in tm2py/emme/manager.py def close_all ( self ): \"\"\" Close all open cached Emme project(s). Should be called at the end of the model process / Emme assignments. \"\"\" while self . _project_cache : _ , app = self . _project_cache . popitem () app . close ()","title":"close_all()"},{"location":"api/#tm2py.emme.manager.EmmeManager.copy_attr_values","text":"Copy attribute values between Emme scenario (on disk) and network (in memory). Parameters: Name Type Description Default domain str attribute domain, one of \u201cNODE\u201d, \u201cLINK\u201d, \u201cTURN\u201d, \u201cTRANSIT_LINE\u201d, \u201cTRANSIT_SEGMENT\u201d required src Union[<MagicMock name='mock.Scenario' id='140339788649712'>, <MagicMock name='mock.Network' id='140339788637712'>] source Emme scenario or network to load values from required dst Union[<MagicMock name='mock.Scenario' id='140339788649712'>, <MagicMock name='mock.Network' id='140339788637712'>] destination Emme scenario or network to save values to required src_names List[str] names of the attributes for loading values required dst_names List[str] optional, names of the attributes to save values as, defaults to using the src_names if not specified None Returns: Type Description Emme Modeller object, see Emme API Reference, Modeller section for details. Source code in tm2py/emme/manager.py @staticmethod def copy_attr_values ( domain : str , src : Union [ EmmeScenario , EmmeNetwork ], dst : Union [ EmmeScenario , EmmeNetwork ], src_names : List [ str ], dst_names : List [ str ] = None , ): \"\"\"Copy attribute values between Emme scenario (on disk) and network (in memory). Args: domain: attribute domain, one of \"NODE\", \"LINK\", \"TURN\", \"TRANSIT_LINE\", \"TRANSIT_SEGMENT\" src: source Emme scenario or network to load values from dst: destination Emme scenario or network to save values to src_names: names of the attributes for loading values dst_names: optional, names of the attributes to save values as, defaults to using the src_names if not specified Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" if dst_names is None : dst_names = src_names values = src . get_attribute_values ( domain , src_names ) dst . set_attribute_values ( domain , dst_names , values )","title":"copy_attr_values()"},{"location":"api/#tm2py.emme.manager.EmmeManager.create_project","text":"Create, open and return Emme project Parameters: Name Type Description Default project_dir str path to Emme root directory for new Emme project required name str name for the Emme project required Returns: Type Description <MagicMock name='mock.emme.desktop.app.App' id='140339788257936'> Emme Desktop App object, see Emme API Reference, Desktop section for details. Source code in tm2py/emme/manager.py def create_project ( self , project_dir : str , name : str ) -> EmmeDesktopApp : \"\"\"Create, open and return Emme project Args: project_dir: path to Emme root directory for new Emme project name: name for the Emme project Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" emp_path = _app . create_project ( project_dir , name ) return self . project ( emp_path )","title":"create_project()"},{"location":"api/#tm2py.emme.manager.EmmeManager.emmebank","text":"Open and return the Emmebank at path. Parameters: Name Type Description Default path str valid system path pointing to an Emmebank file required Returns: Type Description <MagicMock name='mock.Emmebank' id='140339788584896'> Emmebank object, see Emme API Reference, Database section for details. Source code in tm2py/emme/manager.py @staticmethod def emmebank ( path : str ) -> Emmebank : \"\"\"Open and return the Emmebank at path. Args: path: valid system path pointing to an Emmebank file Returns: Emmebank object, see Emme API Reference, Database section for details. \"\"\" if not path . endswith ( \"emmebank\" ): path = os . path . join ( path , \"emmebank\" ) return Emmebank ( path )","title":"emmebank()"},{"location":"api/#tm2py.emme.manager.EmmeManager.get_network","text":"Read partial Emme network from the scenario for the domains and attributes specified. Optimized load of network object from scenario (disk / emmebank) for only the domains specified, and only reads the attributes specified. The attributes is a dictionary with keys for the required domains, and values as lists of the attributes required by domain. Wrapper for scenario.get_partial_network followed by scenario.get_attribute_values and network.set_attribute_values. Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object, see Emme API reference required attributes Dict[str, List[str]] dictionary of domain names to lists of attribute names None Returns: Type Description <MagicMock name='mock.Network' id='140339788637712'> Emme Network object, see Emme API Reference, Network section for details. Source code in tm2py/emme/manager.py def get_network ( self , scenario : EmmeScenario , attributes : Dict [ str , List [ str ]] = None ) -> EmmeNetwork : \"\"\"Read partial Emme network from the scenario for the domains and attributes specified. Optimized load of network object from scenario (disk / emmebank) for only the domains specified, and only reads the attributes specified. The attributes is a dictionary with keys for the required domains, and values as lists of the attributes required by domain. Wrapper for scenario.get_partial_network followed by scenario.get_attribute_values and network.set_attribute_values. Args: scenario: Emme scenario object, see Emme API reference attributes: dictionary of domain names to lists of attribute names Returns: Emme Network object, see Emme API Reference, Network section for details. \"\"\" if attributes is None : return scenario . get_network () network = scenario . get_partial_network ( attributes . keys (), include_attributes = False ) for domain , attrs in attributes . items (): if attrs : self . copy_attr_values ( domain , scenario , network , attrs ) return network","title":"get_network()"},{"location":"api/#tm2py.emme.manager.EmmeManager.logbook_trace","text":"Write an entry to the Modeller logbook and create a nest in the Logbook. Wrapper for inro.modeller.logbook_trace. Used in the with statement, e.g. with _emme_tools.logbook_trace('My nest'): _emme_tools.logbook_write('This entry is nested') Parameters: Name Type Description Default name str The title of the logbook entry required attributes Dict[str, Any] Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. None value str Optional. An HTML string value to be displayed in main detail pane of the logbook entry. None Source code in tm2py/emme/manager.py @staticmethod @_context def logbook_trace ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Modeller logbook and create a nest in the Logbook. Wrapper for inro.modeller.logbook_trace. Used in the with statement, e.g. ``` with _emme_tools.logbook_trace('My nest'): _emme_tools.logbook_write('This entry is nested') ``` Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry. \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} with logbook_trace ( name , value = value , attributes = attributes ): yield","title":"logbook_trace()"},{"location":"api/#tm2py.emme.manager.EmmeManager.logbook_write","text":"Write an entry to the Emme Logbook at the current nesting level. Wrapper for inro.modeller.logbook_write. Parameters: Name Type Description Default name str The title of the logbook entry required attributes Dict[str, Any] Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. None value str Optional. An HTML string value to be displayed in main detail pane of the logbook entry None Source code in tm2py/emme/manager.py @staticmethod def logbook_write ( name : str , value : str = None , attributes : Dict [ str , Any ] = None ): \"\"\"Write an entry to the Emme Logbook at the current nesting level. Wrapper for inro.modeller.logbook_write. Args: name: The title of the logbook entry attributes: Optional. A Python dictionary of key-value pairs to be displayed in the logbook entry detailed view. value: Optional. An HTML string value to be displayed in main detail pane of the logbook entry \"\"\" # pylint: disable=E0611, E0401, E1101 attributes = attributes if attributes else {} logbook_write ( name , value = value , attributes = attributes )","title":"logbook_write()"},{"location":"api/#tm2py.emme.manager.EmmeManager.modeller","text":"Initialize and return Modeller object. If Modeller has not already been initialized it will do so on specified Emme project, or the first Emme project opened if not provided. If already initialized Modeller will reference whichever project was used first. Parameters: Name Type Description Default emme_project <MagicMock name='mock.emme.desktop.app.App' id='140339788257936'> open \u2018Emme Desktop\u2019 application (inro.emme.desktop.app) None Returns: Type Description <MagicMock name='mock.Modeller' id='140339788213744'> Emme Modeller object, see Emme API Reference, Modeller section for details. Source code in tm2py/emme/manager.py def modeller ( self , emme_project : EmmeDesktopApp = None ) -> EmmeModeller : \"\"\"Initialize and return Modeller object. If Modeller has not already been initialized it will do so on specified Emme project, or the first Emme project opened if not provided. If already initialized Modeller will reference whichever project was used first. Args: emme_project: open 'Emme Desktop' application (inro.emme.desktop.app) Returns: Emme Modeller object, see Emme API Reference, Modeller section for details. \"\"\" # pylint: disable=E0611, E0401, E1101 try : return EmmeModeller () except AssertionError as error : if emme_project is None : if self . _project_cache : emme_project = next ( iter ( self . _project_cache . values ())) else : raise Exception ( \"modeller not yet initialized and no cached Emme project,\" \" emme_project arg must be provided\" ) from error return EmmeModeller ( emme_project )","title":"modeller()"},{"location":"api/#tm2py.emme.manager.EmmeManager.project","text":"Return already open Emme project, or open new Desktop session if not found. Parameters: Name Type Description Default project_path str valid path to Emme project *.emp file required Returns: Type Description <MagicMock name='mock.emme.desktop.app.App' id='140339788257936'> Emme Desktop App object, see Emme API Reference, Desktop section for details. Source code in tm2py/emme/manager.py def project ( self , project_path : str ) -> EmmeDesktopApp : \"\"\"Return already open Emme project, or open new Desktop session if not found. Args: project_path: valid path to Emme project *.emp file Returns: Emme Desktop App object, see Emme API Reference, Desktop section for details. \"\"\" project_path = os . path . normcase ( os . path . realpath ( project_path )) emme_project = self . _project_cache . get ( project_path ) if emme_project : try : # Check if the Emme window was closed emme_project . current_window () except _socket_error : emme_project = None # if window is not opened in this process, start a new one if emme_project is None : if not os . path . isfile ( project_path ): raise Exception ( f \"Emme project path does not exist { project_path } \" ) emme_project = _app . start_dedicated ( visible = True , user_initials = \"inro\" , project = project_path ) self . _project_cache [ project_path ] = emme_project return emme_project","title":"project()"},{"location":"api/#tm2py.emme.manager.EmmeManager.temp_attributes_and_restore","text":"Create temp extra attribute and network field, and backup values and state and restore. Allows the use of temporary attributes which may conflict with existing attributes. The temp created attributes are deleted at the end, and if there were pre-existing attributes with the same names the values are restored. Note that name conflicts may still arise in the shorthand inheritance systems for the network hierarchy tree (@node attribute reserves -> @nodei, @nodej, etc, see Emme help Network calculations for full list) which will raise an error in the Emme API. Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object required attributes List[List[str]] list of attribute details, where details is a list of 3 items for extra attributes and 4 for network fields: domain, name, description[, atype] required Source code in tm2py/emme/manager.py @staticmethod @_context def temp_attributes_and_restore ( scenario : EmmeScenario , attributes : List [ List [ str ]] ): \"\"\"Create temp extra attribute and network field, and backup values and state and restore. Allows the use of temporary attributes which may conflict with existing attributes. The temp created attributes are deleted at the end, and if there were pre-existing attributes with the same names the values are restored. Note that name conflicts may still arise in the shorthand inheritance systems for the network hierarchy tree (@node attribute reserves -> @nodei, @nodej, etc, see Emme help Network calculations for full list) which will raise an error in the Emme API. Args: scenario: Emme scenario object attributes: list of attribute details, where details is a list of 3 items for extra attributes and 4 for network fields: domain, name, description[, atype] \"\"\" attrs_to_delete = [] fields_to_delete = [] attrs_to_restore = dict ( ( d , []) for d in [ \"NODE\" , \"LINK\" , \"TURN\" , \"TRANSIT_LINE\" , \"TRANSIT_SEGMENT\" ] ) for details in attributes : domain , name , desc = details [: 3 ] attr = scenario . extra_attribute ( name ) field = scenario . network_field ( domain , name ) if attr or field : attrs_to_restore [ domain ] . append ( name ) elif name . startswith ( \"@\" ): attr = scenario . create_extra_attribute ( domain , name ) attr . description = desc attrs_to_delete . append ( name ) else : atype = details [ 3 ] field = scenario . create_nertwork_field ( domain , name , atype ) field . description = desc fields_to_delete . append (( domain , name )) backup = [] for domain , names in attrs_to_restore . items (): if names : backup . append ( ( domain , names , scenario . get_attribute_values ( domain , names )) ) try : yield finally : for name in attrs_to_delete : scenario . delete_extra_attribute ( name ) for domain , name in fields_to_delete : scenario . delete_network_field ( domain , name ) for domain , names , values in backup : scenario . set_attribute_values ( domain , names , values )","title":"temp_attributes_and_restore()"},{"location":"api/#tm2py.emme.manager.EmmeManager.tool","text":"Return the Modeller tool at namespace. Returns: Type Description Corresponding Tool object, see Emme Help for full details. Source code in tm2py/emme/manager.py def tool ( self , namespace : str ): \"\"\"Return the Modeller tool at namespace. Returns: Corresponding Tool object, see Emme Help for full details. \"\"\" return self . modeller () . tool ( namespace )","title":"tool()"},{"location":"api/#tm2py.emme.matrix","text":"Module for Emme-related matrix management. Contains the MatrixCache class for write through matrix data management of Emme matrices (in Emmebank) to avoid repeated read-from-disk of skim matrices during post-assignment processing and export to OMX. Contains the OMXManager which is a thin wrapper on the openmatrix (OMX) library for transfer between Emme (emmebank) <-> OMX files. Integrates with the MatrixCache to support easy write from Emmebank without re-reading data from disk.","title":"matrix"},{"location":"api/#tm2py.emme.matrix.MatrixCache","text":"Write through cache of Emme matrix data via Numpy arrays Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> reference scenario for the active Emmebank and matrix zone system required Source code in tm2py/emme/matrix.py class MatrixCache : \"\"\"Write through cache of Emme matrix data via Numpy arrays Args: scenario: reference scenario for the active Emmebank and matrix zone system \"\"\" def __init__ ( self , scenario : EmmeScenario ): self . _scenario = scenario self . _emmebank = scenario . emmebank # mapping from matrix object to last read/write timestamp for cache invalidation self . _timestamps = {} # cache of Emme matrix data, key: matrix object, value: numpy array of data self . _data = {} def get_data ( self , matrix : Union [ str , EmmeMatrix ]) -> NumpyArray : \"\"\"Get Emme matrix data as numpy array. Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank Returns: The Numpy array of values for this matrix / matrix ID. \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) timestamp = matrix . timestamp prev_timestamp = self . _timestamps . get ( matrix ) if prev_timestamp is None or ( timestamp != prev_timestamp ): self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = matrix . get_numpy_data ( self . _scenario . id ) return self . _data [ matrix ] def set_data ( self , matrix : Union [ str , EmmeMatrix ], data : NumpyArray ): \"\"\"Set numpy array to Emme matrix (write through cache). Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank data: Numpy array, must match the scenario zone system \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) matrix . set_numpy_data ( data , self . _scenario . id ) self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = data def clear ( self ): \"\"\"Clear the cache.\"\"\" self . _timestamps = {} self . _data = {}","title":"MatrixCache"},{"location":"api/#tm2py.emme.matrix.MatrixCache.clear","text":"Clear the cache. Source code in tm2py/emme/matrix.py def clear ( self ): \"\"\"Clear the cache.\"\"\" self . _timestamps = {} self . _data = {}","title":"clear()"},{"location":"api/#tm2py.emme.matrix.MatrixCache.get_data","text":"Get Emme matrix data as numpy array. Parameters: Name Type Description Default matrix Union[str, <MagicMock name='mock.Matrix' id='140339788665808'>] Emme matrix object or unique name / ID for Emme matrix in Emmebank required Returns: Type Description <built-in function array> The Numpy array of values for this matrix / matrix ID. Source code in tm2py/emme/matrix.py def get_data ( self , matrix : Union [ str , EmmeMatrix ]) -> NumpyArray : \"\"\"Get Emme matrix data as numpy array. Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank Returns: The Numpy array of values for this matrix / matrix ID. \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) timestamp = matrix . timestamp prev_timestamp = self . _timestamps . get ( matrix ) if prev_timestamp is None or ( timestamp != prev_timestamp ): self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = matrix . get_numpy_data ( self . _scenario . id ) return self . _data [ matrix ]","title":"get_data()"},{"location":"api/#tm2py.emme.matrix.MatrixCache.set_data","text":"Set numpy array to Emme matrix (write through cache). Parameters: Name Type Description Default matrix Union[str, <MagicMock name='mock.Matrix' id='140339788665808'>] Emme matrix object or unique name / ID for Emme matrix in Emmebank required data <built-in function array> Numpy array, must match the scenario zone system required Source code in tm2py/emme/matrix.py def set_data ( self , matrix : Union [ str , EmmeMatrix ], data : NumpyArray ): \"\"\"Set numpy array to Emme matrix (write through cache). Args: matrix: Emme matrix object or unique name / ID for Emme matrix in Emmebank data: Numpy array, must match the scenario zone system \"\"\" if isinstance ( matrix , str ): matrix = self . _emmebank . matrix ( matrix ) matrix . set_numpy_data ( data , self . _scenario . id ) self . _timestamps [ matrix ] = matrix . timestamp self . _data [ matrix ] = data","title":"set_data()"},{"location":"api/#tm2py.emme.matrix.OMXManager","text":"Wrapper for the OMX interface to write from Emme matrices and numpy arrays. Write from Emmebank or Matrix Cache to OMX file, or read from OMX to Numpy. Also supports with statement. Parameters: Name Type Description Default file_path str path of OMX file required mode str \u201cr\u201d, \u201cw\u201d or \u201ca\u201d 'r' scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object for zone system and reference Emmebank None omx_key str \u201cID_NAME\u201d, \u201cNAME\u201d, \u201cID\u201d, format for generating OMX key from Emme matrix data 'NAME' matrix_cache MatrixCache optional, Matrix Cache to support write data from cache (instead of always reading from Emmmebank) None mask_max_value float optional, max value above which to write zero instead (\u201cbig to zero\u201d behavior) None Source code in tm2py/emme/matrix.py class OMXManager : \"\"\"Wrapper for the OMX interface to write from Emme matrices and numpy arrays. Write from Emmebank or Matrix Cache to OMX file, or read from OMX to Numpy. Also supports with statement. Args: file_path: path of OMX file mode: \"r\", \"w\" or \"a\" scenario: Emme scenario object for zone system and reference Emmebank omx_key: \"ID_NAME\", \"NAME\", \"ID\", format for generating OMX key from Emme matrix data matrix_cache: optional, Matrix Cache to support write data from cache (instead of always reading from Emmmebank) mask_max_value: optional, max value above which to write zero instead (\"big to zero\" behavior) \"\"\" def __init__ ( self , file_path : str , mode : str = \"r\" , scenario : EmmeScenario = None , omx_key : str = \"NAME\" , matrix_cache : MatrixCache = None , mask_max_value : float = None , ): # pylint: disable=R0913 self . _file_path = file_path self . _mode = mode self . _scenario = scenario self . _omx_key = omx_key self . _mask_max_value = mask_max_value self . _omx_file = None self . _emme_matrix_cache = matrix_cache self . _read_cache = {} def _generate_name ( self , matrix : EmmeMatrix ) -> str : if self . _omx_key == \"ID_NAME\" : return f \" { matrix . id } _ { matrix . name } \" if self . _omx_key == \"NAME\" : return matrix . name if self . _omx_key == \"ID\" : return matrix . id raise Exception ( f \"invalid omx_key: { self . _omx_key } \" ) def open ( self ): \"\"\"Open the OMX file.\"\"\" self . _omx_file = _omx . open_file ( self . _file_path , self . _mode ) def close ( self ): \"\"\"Close the OMX file.\"\"\" if self . _omx_file is not None : self . _omx_file . close () self . _omx_file = None self . _read_cache = {} def __enter__ ( self ): self . open () if self . _mode in [ \"a\" , \"w\" ] and self . _scenario is not None : try : self . _omx_file . create_mapping ( \"zone_number\" , self . _scenario . zone_numbers ) except LookupError : pass return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . close () def write_matrices ( self , matrices : List [ Union [ EmmeMatrix , str ]]): \"\"\"Write the list of emme matrices to OMX file. Args: matrices: list of Emme matrix objects or names / IDs of matrices in Emmebank, or dictionary of name: Emme matrix object/ Emme matrix ID \"\"\" if isinstance ( matrices , dict ): for key , matrix in matrices . items (): self . write_matrix ( matrix , key ) else : for matrix in matrices : self . write_matrix ( matrix ) def write_matrix ( self , matrix : [ str , EmmeMatrix ], name = None ): \"\"\"Write Emme matrix (as name or ID or Emme matrix object). Args: matrix: Emme matrix object or name / ID of matrix in Emmebank name: optional name to use for OMX key, if not specified the omx_key format will be used to generate a name from the Emme matrix data \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) if isinstance ( matrix , str ): matrix = self . _scenario . emmebank . matrix ( matrix ) if name is None : name = self . _generate_name ( matrix ) if self . _emme_matrix_cache : numpy_array = self . _emme_matrix_cache . get_data ( matrix ) else : numpy_array = matrix . get_numpy_data ( self . _scenario . id ) if matrix . type == \"DESTINATION\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( 1 , n_zones )) elif matrix . type == \"ORIGIN\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( n_zones , 1 )) attrs = { \"description\" : matrix . description } self . write_array ( numpy_array , name , attrs ) def write_clipped_array ( self , numpy_array : NumpyArray , name : str , a_min : float , a_max : float = None , attrs : Dict [ str , str ] = None , ): # pylint: disable=R0913 \"\"\"Write array with min and max values capped. Args: numpy_array: Numpy array name: name to use for the OMX key a_min: minimum value to clip array data a_max: optional maximum value to clip array data attrs: additional attribute key value pairs to write to OMX file \"\"\" if a_max is not None : numpy_array = numpy_array . clip ( a_min , a_max ) else : numpy_array = numpy_array . clip ( a_min ) self . write_array ( numpy_array , name , attrs ) def write_array ( self , numpy_array : NumpyArray , name : str , attrs : Dict [ str , str ] = None ): \"\"\"Write array with name and optional attrs to OMX file. Args: numpy_array:: Numpy array name: name to use for the OMX key attrs: additional attribute key value pairs to write to OMX file \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) shape = numpy_array . shape if len ( shape ) == 2 : chunkshape = ( 1 , shape [ 0 ]) else : chunkshape = None if self . _mask_max_value : numpy_array [ numpy_array > self . _mask_max_value ] = 0 numpy_array = numpy_array . astype ( dtype = \"float64\" , copy = False ) self . _omx_file . create_matrix ( name , obj = numpy_array , chunkshape = chunkshape , attrs = attrs ) def read ( self , name : str ) -> NumpyArray : \"\"\"Read OMX data as numpy array (standard interface). Caches matrix data (arrays) already read from disk. Args: name: name of OMX matrix Returns: Numpy array from OMX file \"\"\" if name in self . _read_cache : return self . _read_cache [ name ] data = self . _omx_file [ name ] . read () self . _read_cache [ name ] = data return data def read_hdf5 ( self , path : str ) -> NumpyArray : \"\"\"Read data directly from PyTables interface. Support for hdf5 formats that don't have full OMX compatibility. Args: path: hdf5 reference path to matrix data Returns: Numpy array from OMX file \"\"\" return self . _omx_file . get_node ( path ) . read ()","title":"OMXManager"},{"location":"api/#tm2py.emme.matrix.OMXManager.close","text":"Close the OMX file. Source code in tm2py/emme/matrix.py def close ( self ): \"\"\"Close the OMX file.\"\"\" if self . _omx_file is not None : self . _omx_file . close () self . _omx_file = None self . _read_cache = {}","title":"close()"},{"location":"api/#tm2py.emme.matrix.OMXManager.open","text":"Open the OMX file. Source code in tm2py/emme/matrix.py def open ( self ): \"\"\"Open the OMX file.\"\"\" self . _omx_file = _omx . open_file ( self . _file_path , self . _mode )","title":"open()"},{"location":"api/#tm2py.emme.matrix.OMXManager.read","text":"Read OMX data as numpy array (standard interface). Caches matrix data (arrays) already read from disk. Parameters: Name Type Description Default name str name of OMX matrix required Returns: Type Description <built-in function array> Numpy array from OMX file Source code in tm2py/emme/matrix.py def read ( self , name : str ) -> NumpyArray : \"\"\"Read OMX data as numpy array (standard interface). Caches matrix data (arrays) already read from disk. Args: name: name of OMX matrix Returns: Numpy array from OMX file \"\"\" if name in self . _read_cache : return self . _read_cache [ name ] data = self . _omx_file [ name ] . read () self . _read_cache [ name ] = data return data","title":"read()"},{"location":"api/#tm2py.emme.matrix.OMXManager.read_hdf5","text":"Read data directly from PyTables interface. Support for hdf5 formats that don\u2019t have full OMX compatibility. Parameters: Name Type Description Default path str hdf5 reference path to matrix data required Returns: Type Description <built-in function array> Numpy array from OMX file Source code in tm2py/emme/matrix.py def read_hdf5 ( self , path : str ) -> NumpyArray : \"\"\"Read data directly from PyTables interface. Support for hdf5 formats that don't have full OMX compatibility. Args: path: hdf5 reference path to matrix data Returns: Numpy array from OMX file \"\"\" return self . _omx_file . get_node ( path ) . read ()","title":"read_hdf5()"},{"location":"api/#tm2py.emme.matrix.OMXManager.write_array","text":"Write array with name and optional attrs to OMX file. Parameters: Name Type Description Default numpy_array <built-in function array> : Numpy array required name str name to use for the OMX key required attrs Dict[str, str] additional attribute key value pairs to write to OMX file None Source code in tm2py/emme/matrix.py def write_array ( self , numpy_array : NumpyArray , name : str , attrs : Dict [ str , str ] = None ): \"\"\"Write array with name and optional attrs to OMX file. Args: numpy_array:: Numpy array name: name to use for the OMX key attrs: additional attribute key value pairs to write to OMX file \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) shape = numpy_array . shape if len ( shape ) == 2 : chunkshape = ( 1 , shape [ 0 ]) else : chunkshape = None if self . _mask_max_value : numpy_array [ numpy_array > self . _mask_max_value ] = 0 numpy_array = numpy_array . astype ( dtype = \"float64\" , copy = False ) self . _omx_file . create_matrix ( name , obj = numpy_array , chunkshape = chunkshape , attrs = attrs )","title":"write_array()"},{"location":"api/#tm2py.emme.matrix.OMXManager.write_clipped_array","text":"Write array with min and max values capped. Parameters: Name Type Description Default numpy_array <built-in function array> Numpy array required name str name to use for the OMX key required a_min float minimum value to clip array data required a_max float optional maximum value to clip array data None attrs Dict[str, str] additional attribute key value pairs to write to OMX file None Source code in tm2py/emme/matrix.py def write_clipped_array ( self , numpy_array : NumpyArray , name : str , a_min : float , a_max : float = None , attrs : Dict [ str , str ] = None , ): # pylint: disable=R0913 \"\"\"Write array with min and max values capped. Args: numpy_array: Numpy array name: name to use for the OMX key a_min: minimum value to clip array data a_max: optional maximum value to clip array data attrs: additional attribute key value pairs to write to OMX file \"\"\" if a_max is not None : numpy_array = numpy_array . clip ( a_min , a_max ) else : numpy_array = numpy_array . clip ( a_min ) self . write_array ( numpy_array , name , attrs )","title":"write_clipped_array()"},{"location":"api/#tm2py.emme.matrix.OMXManager.write_matrices","text":"Write the list of emme matrices to OMX file. Parameters: Name Type Description Default matrices List[Union[<MagicMock name='mock.Matrix' id='140339788665808'>, str]] list of Emme matrix objects or names / IDs of matrices in Emmebank, or dictionary of name: Emme matrix object/ Emme matrix ID required Source code in tm2py/emme/matrix.py def write_matrices ( self , matrices : List [ Union [ EmmeMatrix , str ]]): \"\"\"Write the list of emme matrices to OMX file. Args: matrices: list of Emme matrix objects or names / IDs of matrices in Emmebank, or dictionary of name: Emme matrix object/ Emme matrix ID \"\"\" if isinstance ( matrices , dict ): for key , matrix in matrices . items (): self . write_matrix ( matrix , key ) else : for matrix in matrices : self . write_matrix ( matrix )","title":"write_matrices()"},{"location":"api/#tm2py.emme.matrix.OMXManager.write_matrix","text":"Write Emme matrix (as name or ID or Emme matrix object). Parameters: Name Type Description Default matrix [<class 'str'>, <MagicMock name='mock.Matrix' id='140339788665808'>] Emme matrix object or name / ID of matrix in Emmebank required name optional name to use for OMX key, if not specified the omx_key format will be used to generate a name from the Emme matrix data None Source code in tm2py/emme/matrix.py def write_matrix ( self , matrix : [ str , EmmeMatrix ], name = None ): \"\"\"Write Emme matrix (as name or ID or Emme matrix object). Args: matrix: Emme matrix object or name / ID of matrix in Emmebank name: optional name to use for OMX key, if not specified the omx_key format will be used to generate a name from the Emme matrix data \"\"\" if self . _mode not in [ \"a\" , \"w\" ]: raise Exception ( f \" { self . _file_path } : open in read-only mode\" ) if isinstance ( matrix , str ): matrix = self . _scenario . emmebank . matrix ( matrix ) if name is None : name = self . _generate_name ( matrix ) if self . _emme_matrix_cache : numpy_array = self . _emme_matrix_cache . get_data ( matrix ) else : numpy_array = matrix . get_numpy_data ( self . _scenario . id ) if matrix . type == \"DESTINATION\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( 1 , n_zones )) elif matrix . type == \"ORIGIN\" : n_zones = len ( numpy_array ) numpy_array = resize ( numpy_array , ( n_zones , 1 )) attrs = { \"description\" : matrix . description } self . write_array ( numpy_array , name , attrs )","title":"write_matrix()"},{"location":"api/#tm2py.emme.network","text":"Module for Emme network calculations. Contains NetworkCalculator class to generate Emme format specifications for the Network calculator.","title":"network"},{"location":"api/#tm2py.emme.network.NetworkCalculator","text":"Simple wrapper interface to the Emme Network calculator Used to generate the standard network calculator specification (dictionary) from argument inputs. Useful when NOT (commonly) using selection or aggregation options, and mostly running link expression calculations Parameters: Name Type Description Default scenario <MagicMock name='mock.Scenario' id='140339788649712'> Emme scenario object required Source code in tm2py/emme/network.py class NetworkCalculator : \"\"\"Simple wrapper interface to the Emme Network calculator Used to generate the standard network calculator specification (dictionary) from argument inputs. Useful when NOT (commonly) using selection or aggregation options, and mostly running link expression calculations Args: scenario: Emme scenario object \"\"\" def __init__ ( self , scenario : EmmeScenario ): self . _scenario = scenario emme_manager = _manager . EmmeManager () modeller = emme_manager . modeller () self . _network_calc = modeller . tool ( \"inro.emme.network_calculation.network_calculator\" ) self . _specs = [] def __call__ ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ) -> Dict [ str , float ]: \"\"\"Run a network calculation in the scenario, see the Emme help for more. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. Returns: A dictionary report with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" spec = self . _format_spec ( result , expression , selections , aggregation ) return self . _network_calc ( spec , self . _scenario ) def add_calc ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ): \"\"\"Add calculation to list of network calculations to run. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. \"\"\" self . _specs . append ( self . _format_spec ( result , expression , selections , aggregation ) ) def run ( self ) -> List [ Dict [ str , float ]]: \"\"\"Run accumulated network calculations all at once. Returns: A list of dictionary reports with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" reports = self . _network_calc ( self . _specs , self . _scenario ) self . _specs = [] return reports @staticmethod def _format_spec ( result : str , expression : str , selections : Union [ str , Dict [ str , str ]], aggregation : Dict [ str , str ], ) -> EmmeNetworkCalcSpecification : spec = { \"result\" : result , \"expression\" : expression , \"aggregation\" : aggregation , \"type\" : \"NETWORK_CALCULATION\" , } if selections is not None : if isinstance ( selections , str ): selections = { \"link\" : selections } spec [ \"selections\" ] = selections else : spec [ \"selections\" ] = { \"link\" : \"all\" } return spec","title":"NetworkCalculator"},{"location":"api/#tm2py.emme.network.NetworkCalculator.__call__","text":"Run a network calculation in the scenario, see the Emme help for more. Parameters: Name Type Description Default result str Name of network attribute required expression str Calculation expression required selections Union[str, Dict[str, str]] Selection expression nest. Defaults to {\u201clink\u201d: \u201call\u201d} if not specified, and is used as a link selection expression if specified as a string. None aggregation Dict[str, str] Aggregation operators if aggregating between network domains. None Returns: Type Description Dict[str, float] A dictionary report with min, max, average and sum of the calculation expression. See Emme help \u2018Network calculator\u2019 for more. Source code in tm2py/emme/network.py def __call__ ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ) -> Dict [ str , float ]: \"\"\"Run a network calculation in the scenario, see the Emme help for more. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. Returns: A dictionary report with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" spec = self . _format_spec ( result , expression , selections , aggregation ) return self . _network_calc ( spec , self . _scenario )","title":"__call__()"},{"location":"api/#tm2py.emme.network.NetworkCalculator.add_calc","text":"Add calculation to list of network calculations to run. Parameters: Name Type Description Default result str Name of network attribute required expression str Calculation expression required selections Union[str, Dict[str, str]] Selection expression nest. Defaults to {\u201clink\u201d: \u201call\u201d} if not specified, and is used as a link selection expression if specified as a string. None aggregation Dict[str, str] Aggregation operators if aggregating between network domains. None Source code in tm2py/emme/network.py def add_calc ( self , result : str , expression : str , selections : Union [ str , Dict [ str , str ]] = None , aggregation : Dict [ str , str ] = None , ): \"\"\"Add calculation to list of network calculations to run. Args: result: Name of network attribute expression: Calculation expression selections: Selection expression nest. Defaults to {\"link\": \"all\"} if not specified, and is used as a link selection expression if specified as a string. aggregation: Aggregation operators if aggregating between network domains. \"\"\" self . _specs . append ( self . _format_spec ( result , expression , selections , aggregation ) )","title":"add_calc()"},{"location":"api/#tm2py.emme.network.NetworkCalculator.run","text":"Run accumulated network calculations all at once. Returns: Type Description List[Dict[str, float]] A list of dictionary reports with min, max, average and sum of the calculation expression. See Emme help \u2018Network calculator\u2019 for more. Source code in tm2py/emme/network.py def run ( self ) -> List [ Dict [ str , float ]]: \"\"\"Run accumulated network calculations all at once. Returns: A list of dictionary reports with min, max, average and sum of the calculation expression. See Emme help 'Network calculator' for more. \"\"\" reports = self . _network_calc ( self . _specs , self . _scenario ) self . _specs = [] return reports","title":"run()"},{"location":"api/#errata","text":"","title":"Errata"},{"location":"api/#tm2py.logger","text":"Logging module","title":"logger"},{"location":"api/#tm2py.logger.LogStartEnd","text":"Log the start and end time with optional message. Used as a Component method decorator. If msg is not provided a default message is generated with the object class and method name. Parameters: Name Type Description Default msg str message text to use in the start and end record None level str logging level 'INFO' Source code in tm2py/logger.py class LogStartEnd : \"\"\"Log the start and end time with optional message. Used as a Component method decorator. If msg is not provided a default message is generated with the object class and method name. Args: msg (str): message text to use in the start and end record level (str): logging level \"\"\" def __init__ ( self , msg : str = None , level : str = \"INFO\" ): self . msg = msg self . level = level def __call__ ( self , func ): @functools . wraps ( func ) def wrapper ( obj , * args , ** kwargs ): msg = self . msg or obj . __class__ . __name__ + \" \" + func . __name__ obj . logger . log_start ( msg , self . level ) value = func ( obj , * args , ** kwargs ) obj . logger . log_end ( msg , self . level ) return value return wrapper","title":"LogStartEnd"},{"location":"api/#tm2py.logger.Logger","text":"Logger Source code in tm2py/logger.py class Logger : \"\"\"Logger\"\"\" def __init__ ( self , controller ): super () . __init__ () self . _controller = controller self . _indentation = 0 @staticmethod def log ( text : str , level : str = \"INFO\" ): \"\"\"Placeholder logging method Args: text (str): text to log level (str): logging level of the message text \"\"\" if level : print ( text ) def log_time ( self , msg : str , level : str = \"INFO\" , indent : bool = True ): \"\"\"Log message with timestamp Args: msg (str): message text level (str): logging level indent (bool): if true indent any messages based on the number of open contexts \"\"\" timestamp = datetime . now () . strftime ( \" %d -%b-%Y (%H:%M:%S)\" ) if indent : indent = \" \" * self . _indentation self . log ( f \" { timestamp } : { indent }{ msg } \" , level ) else : self . log ( f \" { timestamp } : { msg } \" , level ) def log_start ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'Start'. Args: msg (str): message text level (str): logging level \"\"\" self . log_time ( f \"Start { msg } \" , level , indent = True ) self . _indentation += 1 def log_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'End'. Args: msg (str): message text level (str): logging level \"\"\" self . _indentation -= 1 self . log_time ( f \"End { msg } \" , level , indent = True ) @_context def log_start_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Use with 'with' statement to log the start and end time with message. Args: msg (str): message text level (str): logging level \"\"\" self . log_start ( msg , level ) yield self . log_end ( msg , level )","title":"Logger"},{"location":"api/#tm2py.logger.Logger.log","text":"Placeholder logging method Parameters: Name Type Description Default text str text to log required level str logging level of the message text 'INFO' Source code in tm2py/logger.py @staticmethod def log ( text : str , level : str = \"INFO\" ): \"\"\"Placeholder logging method Args: text (str): text to log level (str): logging level of the message text \"\"\" if level : print ( text )","title":"log()"},{"location":"api/#tm2py.logger.Logger.log_end","text":"Log message with timestamp and \u2018End\u2019. Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' Source code in tm2py/logger.py def log_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'End'. Args: msg (str): message text level (str): logging level \"\"\" self . _indentation -= 1 self . log_time ( f \"End { msg } \" , level , indent = True )","title":"log_end()"},{"location":"api/#tm2py.logger.Logger.log_start","text":"Log message with timestamp and \u2018Start\u2019. Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' Source code in tm2py/logger.py def log_start ( self , msg : str , level : str = \"INFO\" ): \"\"\"Log message with timestamp and 'Start'. Args: msg (str): message text level (str): logging level \"\"\" self . log_time ( f \"Start { msg } \" , level , indent = True ) self . _indentation += 1","title":"log_start()"},{"location":"api/#tm2py.logger.Logger.log_start_end","text":"Use with \u2018with\u2019 statement to log the start and end time with message. Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' Source code in tm2py/logger.py @_context def log_start_end ( self , msg : str , level : str = \"INFO\" ): \"\"\"Use with 'with' statement to log the start and end time with message. Args: msg (str): message text level (str): logging level \"\"\" self . log_start ( msg , level ) yield self . log_end ( msg , level )","title":"log_start_end()"},{"location":"api/#tm2py.logger.Logger.log_time","text":"Log message with timestamp Parameters: Name Type Description Default msg str message text required level str logging level 'INFO' indent bool if true indent any messages based on the number of open contexts True Source code in tm2py/logger.py def log_time ( self , msg : str , level : str = \"INFO\" , indent : bool = True ): \"\"\"Log message with timestamp Args: msg (str): message text level (str): logging level indent (bool): if true indent any messages based on the number of open contexts \"\"\" timestamp = datetime . now () . strftime ( \" %d -%b-%Y (%H:%M:%S)\" ) if indent : indent = \" \" * self . _indentation self . log ( f \" { timestamp } : { indent }{ msg } \" , level ) else : self . log ( f \" { timestamp } : { msg } \" , level )","title":"log_time()"},{"location":"api/#tm2py.tools","text":"Tools module for common resources / shared code and \u201cutilities\u201d in the tm2py package.","title":"tools"},{"location":"api/#tm2py.tools.download_unzip","text":"Downloads and unzips a file from a URL. The zip file is removed after extraction. Parameters: Name Type Description Default url str Full URL do download from. required out_base_dir str Where to unzip the file. required target_dir str What to unzip the file as. required zip_filename str Filename to store zip file as. Defaults to \u201ctest_data.zip\u201d. 'test_data.zip' Source code in tm2py/tools.py def download_unzip ( url : str , out_base_dir : str , target_dir : str , zip_filename : str = \"test_data.zip\" ) -> None : \"\"\"Downloads and unzips a file from a URL. The zip file is removed after extraction. Args: url (str): Full URL do download from. out_base_dir (str): Where to unzip the file. target_dir (str): What to unzip the file as. zip_filename (str, optional): Filename to store zip file as. Defaults to \"test_data.zip\". \"\"\" target_zip = os . path . join ( out_base_dir , zip_filename ) if not os . path . isdir ( out_base_dir ): os . makedirs ( out_base_dir ) urllib . request . Request ( url ) _download ( url , target_zip ) _unzip ( target_zip , target_dir ) os . remove ( target_zip )","title":"download_unzip()"},{"location":"api/#tm2py.tools.parse_num_processors","text":"Convert input value (parse if string) to number of processors. Parameters: Name Type Description Default value Union[str, int, float] an int, float or string; string value can be \u201cX\u201d or \u201cMAX-X\u201d required Returns: Type Description An int of the number of processors to use Exceptions: Type Description Exception Input value exceeds number of available processors Exception Input value less than 1 processors Source code in tm2py/tools.py def parse_num_processors ( value : Union [ str , int , float ]): \"\"\"Convert input value (parse if string) to number of processors. Args: value: an int, float or string; string value can be \"X\" or \"MAX-X\" Returns: An int of the number of processors to use Raises: Exception: Input value exceeds number of available processors Exception: Input value less than 1 processors \"\"\" max_processors = multiprocessing . cpu_count () if isinstance ( value , str ): result = value . upper () if result == \"MAX\" : return max_processors if re . match ( \"^[0-9]+$\" , value ): return int ( value ) result = re . split ( r \"^MAX[\\s]*-[\\s]*\" , result ) if len ( result ) == 2 : return max ( max_processors - int ( result [ 1 ]), 1 ) raise Exception ( f \"Input value { value } is an int or string as 'MAX-X'\" ) result = int ( value ) if result > max_processors : raise Exception ( f \"Input value { value } greater than available processors\" ) if result < 1 : raise Exception ( f \"Input value { value } less than 1 processors\" ) return value","title":"parse_num_processors()"},{"location":"api/#tm2py.examples","text":"Download and unzip examples for tm2py, used in tests","title":"examples"},{"location":"api/#tm2py.examples.get_example","text":"Returns example directory; downloads if necessary from retrieval URL. Parameters: Name Type Description Default example_name str Used to retrieve sub-folder or create it if doesn\u2019t exist. Defaults to _DEFAULT_EXAMPLE_NAME. 'UnionCity' example_subdir str Where to find examples within root dir. Defaults to _DEFAULT_EXAMPLE_SUBDIR. 'examples' root_dir str Root dir of project. Defaults to _ROOT_DIR. '..' retrieval_url str URL to retrieve example data zip from. Defaults to _DEFAULT_EXAMPLE_URL. 'https://mtcdrive.box.com/shared/static/3entr016e9teq2wt46x1os3fjqylfoge.zip' Exceptions: Type Description FileNotFoundError If can\u2019t find the files after trying to download it. Returns: Type Description str Path to example data. Source code in tm2py/examples.py def get_example ( example_name : str = _DEFAULT_EXAMPLE_NAME , example_subdir : str = _DEFAULT_EXAMPLE_SUBDIR , root_dir : str = _ROOT_DIR , retrieval_url : str = _DEFAULT_EXAMPLE_URL , ) -> str : \"\"\"Returns example directory; downloads if necessary from retrieval URL. Args: example_name (str, optional): Used to retrieve sub-folder or create it if doesn't exist. Defaults to _DEFAULT_EXAMPLE_NAME. example_subdir (str, optional): Where to find examples within root dir. Defaults to _DEFAULT_EXAMPLE_SUBDIR. root_dir (str, optional): Root dir of project. Defaults to _ROOT_DIR. retrieval_url (str, optional): URL to retrieve example data zip from. Defaults to _DEFAULT_EXAMPLE_URL. Raises: FileNotFoundError: If can't find the files after trying to download it. Returns: str: Path to example data. \"\"\" _example_dir = os . path . join ( root_dir , example_subdir ) _this_example_dir = os . path . join ( _example_dir , example_name ) if os . path . isdir ( _this_example_dir ): return _this_example_dir download_unzip ( retrieval_url , _example_dir , _this_example_dir ) if not os . path . isdir ( _this_example_dir ): raise FileNotFoundError ( f \"example { _this_example_dir } not found\" ) return _this_example_dir","title":"get_example()"},{"location":"architecture/","text":"Architecture \u00b6 Abstract Component \u00b6 classDiagram class Component{ +_controller +_trace +validate_inputs() +run() +report_progress() +test_component() +write_top_sheet() } Controllers \u00b6 classDiagram Controller <|-- ModelController class Controller{ _config +_logger +_top_sheet +_trace +validate_inputs() +run() +report_progress() +test_component() +write_top_sheet() } class ModelController{ +_components: String model.Component +_iteration +validate_inputs() +run() +report_progress() +test_component() +write_top_sheet() +run_prepare_emme_networks() +run_non_motorized_skims() +run_airpassenger_model() +run_resident_model() +run_internal_external_model() +run_truck_model() +run_average_demand() +run_highway_assignment() +run_transit_assignment() } class Logger{ +controller +log() } Configs \u00b6 classDiagram class Configuration{ +load() +save() } Utils \u00b6 classDiagram class NetworkCalc{ +_scenario +_network_calc +__call__() +_add_calc() +run() } class OMX{ +_file_path +_mode +_scenario +_omx_key +_omx_file +_matrix_cache +_generate_name() +open() +close() +__enter__() +__exit__() +write_matrices() +write_clipped_array() +write_array() +read() +read_hdf5() } class EmmeProjectCache{ +close_all() +create_project() +project() } class MatrixCache{ +_scenario +_emmebanks +_timestamps +_data +get_data() +set_data() +clear() } Demand \u00b6 classDiagram Component -- AirPassenger: how? Component -- InternalExternal: how? Component -- Truck: how? Component <|-- ResidentsModel ResidentsModel -- InternalExternal: how? ResidentsModel -- AirPassenger: how? class Component{ } class AirPassenger{ +_parameter +_load_demand() +_sum_demand() +_interpolate() +_export_result() } class InternalExternal{ +_parameter +_ix_forecast() +_ix_time_of_day() +_ix_toll_choice() +_export_results() } class ResidentsModel{ +_start_household_manager() +_start_matrix_manager() +_run_resident_model() +_stop_java() } class Truck{ +_parameter +_generation() +_distribution() +_time_of_day() +_toll_choice() +_export_results() } Assignment \u00b6 classDiagram Component <|-- HighwayAssignment Component <|-- AssignMAZSPDemand Component <|-- ActiveModesAssignment ActiveModesAssignment -- TransitAssignment: how? HighwayAssignment -- AssignMAZSPDemand: how? ImportDemand -- HighwayAssignment: how? ActiveModesAssignment -- AssignMAZSPDemand: how? class Component{ } class HighwayAssignment{ +_num_processors +_root_dir +_matrix_cache +_emme_manager +_Emmebank +_skim_matrices +_setup() +_assign_and_skim() +_calc_time_skim() +_set_intrazonal_values() +_export_skims() +_base_spec() +_prepare_traffic_class() +_prepare_path_analyses() } class ImportDemand{ +_root_dir +_scenario +_period +_setup() +_read_demand() } class AssignMAZSPDemand{ +_scenario +_period +_modes +_modeller +_bin_edges +_net_calc +_debug_report +_debug +_mazs +_demand +_max_dist +_network +_root_index +_leaf_index +_setup() +_prepare_network() +_get_county_mazs() +_process_demand() +_group_demand() +_find_roots_and_leaves() +_run_shortest_path() +_assign_flow() } class ActiveModesAssignment{ +_scenario +_modeller +_setup() +_prepare_network() +_run_shortest_path() } class TransitAssignment{ +_root_dir +_emme_manager +_setup() }","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#abstract-component","text":"classDiagram class Component{ +_controller +_trace +validate_inputs() +run() +report_progress() +test_component() +write_top_sheet() }","title":"Abstract Component"},{"location":"architecture/#controllers","text":"classDiagram Controller <|-- ModelController class Controller{ _config +_logger +_top_sheet +_trace +validate_inputs() +run() +report_progress() +test_component() +write_top_sheet() } class ModelController{ +_components: String model.Component +_iteration +validate_inputs() +run() +report_progress() +test_component() +write_top_sheet() +run_prepare_emme_networks() +run_non_motorized_skims() +run_airpassenger_model() +run_resident_model() +run_internal_external_model() +run_truck_model() +run_average_demand() +run_highway_assignment() +run_transit_assignment() } class Logger{ +controller +log() }","title":"Controllers"},{"location":"architecture/#configs","text":"classDiagram class Configuration{ +load() +save() }","title":"Configs"},{"location":"architecture/#utils","text":"classDiagram class NetworkCalc{ +_scenario +_network_calc +__call__() +_add_calc() +run() } class OMX{ +_file_path +_mode +_scenario +_omx_key +_omx_file +_matrix_cache +_generate_name() +open() +close() +__enter__() +__exit__() +write_matrices() +write_clipped_array() +write_array() +read() +read_hdf5() } class EmmeProjectCache{ +close_all() +create_project() +project() } class MatrixCache{ +_scenario +_emmebanks +_timestamps +_data +get_data() +set_data() +clear() }","title":"Utils"},{"location":"architecture/#demand","text":"classDiagram Component -- AirPassenger: how? Component -- InternalExternal: how? Component -- Truck: how? Component <|-- ResidentsModel ResidentsModel -- InternalExternal: how? ResidentsModel -- AirPassenger: how? class Component{ } class AirPassenger{ +_parameter +_load_demand() +_sum_demand() +_interpolate() +_export_result() } class InternalExternal{ +_parameter +_ix_forecast() +_ix_time_of_day() +_ix_toll_choice() +_export_results() } class ResidentsModel{ +_start_household_manager() +_start_matrix_manager() +_run_resident_model() +_stop_java() } class Truck{ +_parameter +_generation() +_distribution() +_time_of_day() +_toll_choice() +_export_results() }","title":"Demand"},{"location":"architecture/#assignment","text":"classDiagram Component <|-- HighwayAssignment Component <|-- AssignMAZSPDemand Component <|-- ActiveModesAssignment ActiveModesAssignment -- TransitAssignment: how? HighwayAssignment -- AssignMAZSPDemand: how? ImportDemand -- HighwayAssignment: how? ActiveModesAssignment -- AssignMAZSPDemand: how? class Component{ } class HighwayAssignment{ +_num_processors +_root_dir +_matrix_cache +_emme_manager +_Emmebank +_skim_matrices +_setup() +_assign_and_skim() +_calc_time_skim() +_set_intrazonal_values() +_export_skims() +_base_spec() +_prepare_traffic_class() +_prepare_path_analyses() } class ImportDemand{ +_root_dir +_scenario +_period +_setup() +_read_demand() } class AssignMAZSPDemand{ +_scenario +_period +_modes +_modeller +_bin_edges +_net_calc +_debug_report +_debug +_mazs +_demand +_max_dist +_network +_root_index +_leaf_index +_setup() +_prepare_network() +_get_county_mazs() +_process_demand() +_group_demand() +_find_roots_and_leaves() +_run_shortest_path() +_assign_flow() } class ActiveModesAssignment{ +_scenario +_modeller +_setup() +_prepare_network() +_run_shortest_path() } class TransitAssignment{ +_root_dir +_emme_manager +_setup() }","title":"Assignment"},{"location":"starting/","text":"Starting Out \u00b6 Installation \u00b6 If you are managing multiple python versions, we suggest using virtualenv or conda virtual environments. The following instructions create and activate a conda environment (recommended) in which you can install: conda env create -f environment.yml conda activate tm2py Basic installation instructions are as follows: pip install tm2py Bleeding Edge \u00b6 If you want to install a more up-to-date or development version, you can do so by installing it from the develop branch as follows: conda env create -f environment.yml conda activate tm2py pip install git+https://github.com/bayareametro/tm2py@develop Developers (from clone) \u00b6 If you are going to be working on Lasso locally, you might want to clone it to your local machine and install it from the clone. The -e will install it in editable mode . conda env create -f environment.yml conda activate tm2py git clone https://github.com/bayareametro/tm2py cd tm2py pip install -e . Notes: The -e installs it in editable mode. If you are not part of the project team and want to contribute code bxack to the project, please fork before you clone and then add the original repository to your upstream origin list per these directions on github . if you wanted to install from a specific tag/version number or branch, replace @main with @<branchname> or @tag If you want to make use of frequent developer updates for network wrangler as well, you can also install it from clone by copying the instructions for cloning and installing Lasso for Network Wrangler If you are going to be doing development, we also recommend: - a good IDE such as VS Code , Sublime Text, etc. with Python syntax highlighting turned on. - GitHub Desktop to locally update your clones Brief Intro \u00b6 Typical Workflow \u00b6 Running Quickstart Jupyter Notebooks \u00b6 To learn basic lasso functionality, please refer to the following jupyter notebooks in the /notebooks directory: ADDME Jupyter notebooks can be started by activating the lasso conda environment and typing jupyter notebook : conda activate tm2py jupyter notebook","title":"Starting Out"},{"location":"starting/#starting-out","text":"","title":"Starting Out"},{"location":"starting/#installation","text":"If you are managing multiple python versions, we suggest using virtualenv or conda virtual environments. The following instructions create and activate a conda environment (recommended) in which you can install: conda env create -f environment.yml conda activate tm2py Basic installation instructions are as follows: pip install tm2py","title":"Installation"},{"location":"starting/#bleeding-edge","text":"If you want to install a more up-to-date or development version, you can do so by installing it from the develop branch as follows: conda env create -f environment.yml conda activate tm2py pip install git+https://github.com/bayareametro/tm2py@develop","title":"Bleeding Edge"},{"location":"starting/#developers-from-clone","text":"If you are going to be working on Lasso locally, you might want to clone it to your local machine and install it from the clone. The -e will install it in editable mode . conda env create -f environment.yml conda activate tm2py git clone https://github.com/bayareametro/tm2py cd tm2py pip install -e . Notes: The -e installs it in editable mode. If you are not part of the project team and want to contribute code bxack to the project, please fork before you clone and then add the original repository to your upstream origin list per these directions on github . if you wanted to install from a specific tag/version number or branch, replace @main with @<branchname> or @tag If you want to make use of frequent developer updates for network wrangler as well, you can also install it from clone by copying the instructions for cloning and installing Lasso for Network Wrangler If you are going to be doing development, we also recommend: - a good IDE such as VS Code , Sublime Text, etc. with Python syntax highlighting turned on. - GitHub Desktop to locally update your clones","title":"Developers (from clone)"},{"location":"starting/#brief-intro","text":"","title":"Brief Intro"},{"location":"starting/#typical-workflow","text":"","title":"Typical Workflow"},{"location":"starting/#running-quickstart-jupyter-notebooks","text":"To learn basic lasso functionality, please refer to the following jupyter notebooks in the /notebooks directory: ADDME Jupyter notebooks can be started by activating the lasso conda environment and typing jupyter notebook : conda activate tm2py jupyter notebook","title":"Running Quickstart Jupyter Notebooks"},{"location":"contributing/documentation/","text":"Documentation \u00b6 Documentation is developed using the Python package mkdocs . Installing \u00b6 Using pip: pip install -r requirements.txt Building Locally \u00b6 Mkdocs documentation webpages can be built using the following shell command from the docs folder: mkdocs build mkdocs serve Deploying documentation \u00b6 Documentation is built and deployed to [http://bayareametro.github.io/tm2py] upon the develop branch successfully passing continuous integration tests (to be updated to master when released) as specified in .github/workflows/docs.yml .","title":"Documentation"},{"location":"contributing/documentation/#documentation","text":"Documentation is developed using the Python package mkdocs .","title":"Documentation"},{"location":"contributing/documentation/#installing","text":"Using pip: pip install -r requirements.txt","title":"Installing"},{"location":"contributing/documentation/#building-locally","text":"Mkdocs documentation webpages can be built using the following shell command from the docs folder: mkdocs build mkdocs serve","title":"Building Locally"},{"location":"contributing/documentation/#deploying-documentation","text":"Documentation is built and deployed to [http://bayareametro.github.io/tm2py] upon the develop branch successfully passing continuous integration tests (to be updated to master when released) as specified in .github/workflows/docs.yml .","title":"Deploying documentation"}]}